{"version":3,"file":"image-comparison-element.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,uC;;;;;;;;;;;;;;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8D;AAC+C;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2EAA6B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,wBAAwB;AAClC,UAAU,sCAAsC;AAChD,UAAU,qDAAqD;AAC/D,UAAU,wCAAwC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,4CAA4C;AACtD;AACA,UAAU,4CAA4C;AACtD;AACA,UAAU,4CAA4C;AACtD;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2BAA2B;AACxD;AACA;AACA;AACA,6BAA6B,uCAAuC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uDAAY;AAC9C;AACA;AACA;AACA;AACA;AACA,6BAA6B,8EAA+B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,uDAAY;AAC5D;AACA;AACA;AACA;AACA,2CAA2C,uDAAY;AACvD,yCAAyC,uDAAY;AACrD;AACA,sCAAsC,uDAAY;AAClD;AACA;AACA,+BAA+B,2EAA4B;AAC3D;AACA;AACA,oDAAoD,uDAAY;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0CAA0C;AAChE;AACA;AACA;AACA,sBAAsB,0CAA0C;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,mC;;;;;;;;;;;;;;;;ACtnBA;AACA;AACA;AACA;AACA;AAC4H;AAC9D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iCAAiC;AACxE,sCAAsC,iCAAiC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yDAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,YAAY,yDAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2EAA6B;AAClE;AACA;AACA,gBAAgB,yDAAe;AAC/B;AACA;AACA;AACA;AACA,YAAY,gEAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gEAAsB;AACtC;AACA;AACA;AACA,YAAY,sDAAY;AACxB;AACA;AACA;AACA;AACA,gBAAgB,gEAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;;;;;;;AClKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,uC;;;;;;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;UC9CA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA,E;;;;;WCPA,wF;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D,E;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC8C;AACM;AAC+B;AACpC;AACD;AAC+D;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,YAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,cAAc;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qCAAqC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qCAAqC;AACpD;AACA;AACA;AACA,+CAA+C,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE;AAC5E;AACA;AACA;AACA,aAAa,uBAAuB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gCAAgC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,cAAc;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,+BAA+B;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,2DAAa;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,UAAU;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,UAAU;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,0DAA0D,WAAW;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iEAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uBAAuB;AACpC,aAAa,uBAAuB;AACpC,aAAa,qBAAqB;AAClC,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,gBAAgB;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wBAAwB;AACrC,aAAa,wBAAwB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2EAA6B;AACzD;AACA;AACA;AACA,qCAAqC,uDAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB,EAAE,8EAA+B;AAC5E;AACA;AACA,sCAAsC,uDAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,2EAA4B;AACnE;AACA;AACA;AACA;AACA,mCAAmC,uDAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2EAA6B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2EAA6B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAY,yCAAyC,uDAAY;AAClG;AACA;AACA,6DAA6D,uDAAY,yBAAyB,uDAAY,yBAAyB,uDAAY;AACnJ;AACA,qCAAqC,uDAAY,4CAA4C,uDAAY,yBAAyB,uDAAY;AAC9I;AACA;AACA;AACA;AACA;AACA,qCAAqC,uDAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAgD;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO,GAAG,OAAO,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE;AAC5F;AACA;AACA;AACA,qDAAqD,OAAO,GAAG,OAAO;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2EAA6B;AACzD;AACA;AACA;AACA,gCAAgC,uDAAY;AAC5C;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB,EAAE,8EAA+B;AAC5E;AACA;AACA,uCAAuC,uDAAY;AACnD;AACA;AACA;AACA;AACA,2CAA2C,2EAA4B;AACvE;AACA;AACA;AACA;AACA,6CAA6C,uDAAY;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAe;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,yCAAyC;AACzC;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,wBAAwB;AACrC,aAAa,wBAAwB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uBAAuB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uBAAuB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iEAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8CAAU;AAClB;AACA;AACA;AACA;AACA,oD","sources":["webpack://image-comparison-element/./public/js/analysis.js","webpack://image-comparison-element/./public/js/coordinates.js","webpack://image-comparison-element/./public/js/drawing.js","webpack://image-comparison-element/./public/js/magnifier.js","webpack://image-comparison-element/./public/js/mip-mapping.js","webpack://image-comparison-element/./public/js/ui-constants.js","webpack://image-comparison-element/webpack/bootstrap","webpack://image-comparison-element/webpack/runtime/define property getters","webpack://image-comparison-element/webpack/runtime/hasOwnProperty shorthand","webpack://image-comparison-element/webpack/runtime/make namespace object","webpack://image-comparison-element/./public/js/image-comparison-element.js"],"sourcesContent":["/**\n * Analysis utilities for the Image Comparison Element.\n * This module provides functions for calculating image quality metrics\n * and performing pixel-level comparisons between images.\n *\n * This version is adapted for the web component and doesn't rely on global state.\n */\n/**\n * Calculates the Peak Signal-to-Noise Ratio (PSNR) between two images.\n *\n * PSNR is a quality metric that measures the similarity between two images.\n * Higher values indicate more similar images. The calculation takes into account\n * the current position and offset of both images, and only compares the\n * overlapping regions.\n *\n * @param imageAData - Pixel data for image A\n * @param imageBData - Pixel data for image B\n * @param imageA - Image A element (for dimensions)\n * @param imageB - Image B element (for dimensions)\n * @param offsetAX - X offset for image A\n * @param offsetAY - Y offset for image A\n * @param offsetBX - X offset for image B\n * @param offsetBY - Y offset for image B\n * @param scale - Current scale factor\n * @returns PSNR value as a formatted string, or \"N/A\" if calculation fails\n */\nexport function calculatePSNRForImages(imageAData, imageBData, imageA, imageB, offsetAX, offsetAY, offsetBX, offsetBY, scale) {\n    // Check if we have both images and their data\n    if (!imageAData || !imageBData || !imageA || !imageB) {\n        return \"PSNR: N/A\";\n    }\n    // Calculate the overlapping region between the two images\n    const overlapInfo = calculateImageOverlap(imageA.width, imageA.height, offsetAX, offsetAY, imageB.width, imageB.height, offsetBX, offsetBY, scale);\n    if (!overlapInfo || overlapInfo.width <= 0 || overlapInfo.height <= 0) {\n        return \"PSNR: No overlap\";\n    }\n    // Calculate MSE (Mean Squared Error) over the overlapping region\n    let mse = 0;\n    let pixelCount = 0;\n    for (let y = 0; y < overlapInfo.height; y++) {\n        for (let x = 0; x < overlapInfo.width; x++) {\n            // Calculate pixel positions in each image\n            const aX = Math.floor(overlapInfo.aStartX + x);\n            const aY = Math.floor(overlapInfo.aStartY + y);\n            const bX = Math.floor(overlapInfo.bStartX + x);\n            const bY = Math.floor(overlapInfo.bStartY + y);\n            // Check bounds\n            if (aX >= 0 && aX < imageA.width && aY >= 0 && aY < imageA.height &&\n                bX >= 0 && bX < imageB.width && bY >= 0 && bY < imageB.height) {\n                // Get pixel indices\n                const aIndex = (aY * imageA.width + aX) * 4;\n                const bIndex = (bY * imageB.width + bX) * 4;\n                // Calculate squared differences for RGB channels\n                const rDiff = imageAData.data[aIndex] - imageBData.data[bIndex];\n                const gDiff = imageAData.data[aIndex + 1] - imageBData.data[bIndex + 1];\n                const bDiff = imageAData.data[aIndex + 2] - imageBData.data[bIndex + 2];\n                mse += rDiff * rDiff + gDiff * gDiff + bDiff * bDiff;\n                pixelCount++;\n            }\n        }\n    }\n    if (pixelCount === 0) {\n        return \"PSNR: No valid pixels\";\n    }\n    // Calculate average MSE\n    mse = mse / (pixelCount * 3); // Divide by 3 for RGB channels\n    if (mse === 0) {\n        return \"PSNR: ∞ (identical)\";\n    }\n    // Calculate PSNR: 20 * log10(MAX_I) - 10 * log10(MSE)\n    // where MAX_I is the maximum possible pixel value (255 for 8-bit)\n    const psnr = 20 * Math.log10(255) - 10 * Math.log10(mse);\n    return `PSNR: ${psnr.toFixed(2)} dB`;\n}\n/**\n * Calculates the overlapping region between two images given their positions and offsets.\n *\n * @param aWidth - Width of image A\n * @param aHeight - Height of image A\n * @param aOffsetX - X offset of image A\n * @param aOffsetY - Y offset of image A\n * @param bWidth - Width of image B\n * @param bHeight - Height of image B\n * @param bOffsetX - X offset of image B\n * @param bOffsetY - Y offset of image B\n * @param scale - Current scale factor\n * @returns Overlap information or null if no overlap\n */\nfunction calculateImageOverlap(aWidth, aHeight, aOffsetX, aOffsetY, bWidth, bHeight, bOffsetX, bOffsetY, scale) {\n    // Convert offsets from screen coordinates to image coordinates\n    const aImageOffsetX = aOffsetX / scale;\n    const aImageOffsetY = aOffsetY / scale;\n    const bImageOffsetX = bOffsetX / scale;\n    const bImageOffsetY = bOffsetY / scale;\n    // Calculate the bounds of each image in a common coordinate system\n    const aLeft = aImageOffsetX;\n    const aTop = aImageOffsetY;\n    const aRight = aLeft + aWidth;\n    const aBottom = aTop + aHeight;\n    const bLeft = bImageOffsetX;\n    const bTop = bImageOffsetY;\n    const bRight = bLeft + bWidth;\n    const bBottom = bTop + bHeight;\n    // Calculate overlap bounds\n    const overlapLeft = Math.max(aLeft, bLeft);\n    const overlapTop = Math.max(aTop, bTop);\n    const overlapRight = Math.min(aRight, bRight);\n    const overlapBottom = Math.min(aBottom, bBottom);\n    // Check if there's actually an overlap\n    if (overlapLeft >= overlapRight || overlapTop >= overlapBottom) {\n        return null;\n    }\n    return {\n        width: overlapRight - overlapLeft,\n        height: overlapBottom - overlapTop,\n        aStartX: overlapLeft - aLeft,\n        aStartY: overlapTop - aTop,\n        bStartX: overlapLeft - bLeft,\n        bStartY: overlapTop - bTop\n    };\n}\n//# sourceMappingURL=analysis.js.map","/**\n * Coordinate conversion utilities for the Image Comparison Element.\n * This module provides functions for converting between image and canvas coordinates,\n * taking into account the current pan, zoom, and individual image offsets.\n *\n * This version is adapted for the web component and takes state as a parameter\n * instead of relying on global state.\n */\n/**\n * Converts image coordinates to canvas coordinates.\n * This takes into account the current pan and zoom settings.\n *\n * @param imageX - X coordinate in image space\n * @param imageY - Y coordinate in image space\n * @param imageType - Which image's coordinate system to use ('A' or 'B')\n * @param state - Component state containing scale and offset information\n * @returns The corresponding coordinates in canvas space\n */\nfunction imageToCanvasCoords(imageX, imageY, imageType = 'A', state) {\n    const offsetX = imageType === 'A' ? state.offsetAX : state.offsetBX;\n    const offsetY = imageType === 'A' ? state.offsetAY : state.offsetBY;\n    return {\n        x: imageX * state.scale + state.offsetX + offsetX,\n        y: imageY * state.scale + state.offsetY + offsetY\n    };\n}\n/**\n * Converts canvas coordinates to image coordinates.\n * This takes into account the current pan and zoom settings.\n *\n * @param canvasX - X coordinate in canvas space\n * @param canvasY - Y coordinate in canvas space\n * @param imageType - Which image's coordinate system to use ('A' or 'B')\n * @param state - Component state containing scale and offset information\n * @returns The corresponding coordinates in image space\n */\nexport function canvasToImageCoords(canvasX, canvasY, imageType = 'A', state) {\n    const offsetX = imageType === 'A' ? state.offsetAX : state.offsetBX;\n    const offsetY = imageType === 'A' ? state.offsetAY : state.offsetBY;\n    return {\n        x: (canvasX - state.offsetX - offsetX) / state.scale,\n        y: (canvasY - state.offsetY - offsetY) / state.scale\n    };\n}\n/**\n * Gets the wipe position in canvas coordinates.\n * Converts the wipe position from image A coordinates to canvas coordinates.\n *\n * @param state - Component state containing wipe position and transformation info\n * @returns The wipe position in canvas coordinates\n */\nexport function getWipePositionInCanvasCoords(state) {\n    return imageToCanvasCoords(state.wipePositionInImageACoords.x, state.wipePositionInImageACoords.y, 'A', state);\n}\n//# sourceMappingURL=coordinates.js.map","/**\n * Drawing utilities for the Image Comparison Element.\n * This module provides all the rendering functionality including image drawing,\n * composite modes, wipe interface, and UI elements.\n *\n * This version is adapted for the web component and takes state as a parameter\n * instead of relying on global state. It matches the original single version\n * clipping and composite algorithms exactly.\n */\nimport { getWipePositionInCanvasCoords } from './coordinates';\nimport { UI_CONSTANTS, calculateRotationHandlePosition, calculateAlphaSliderPosition } from './ui-constants';\n/**\n * Main drawing function that renders the entire canvas based on current state.\n * This is the primary entry point for all rendering operations.\n *\n * @param state - Component state containing all rendering parameters\n * @param drawUI - Whether to draw UI elements (handles, wipe line) - defaults to true\n */\nexport function draw(state, drawUI = true) {\n    if (!state.ctx || !state.canvas)\n        return;\n    // Clear the canvas with black background\n    state.ctx.fillStyle = 'black';\n    state.ctx.fillRect(0, 0, state.canvas.width, state.canvas.height);\n    // Draw checkerboard background if enabled\n    if (state.isCheckerboard) {\n        // Keep checkerboard fixed to canvas like the single version\n        // No offset needed - pattern stays fixed regardless of pan/zoom\n        // Use configurable square size from component state\n        const squareSize = state.checkerboardSquareSize || 10;\n        drawCheckerboard(state.ctx, state.canvas.width, state.canvas.height, 0, 0, squareSize);\n    }\n    // Determine what to draw based on current mode and loaded images\n    if (!state.imageALoaded && !state.imageBLoaded) {\n        // No images loaded - help screen will be shown by the component\n        return;\n    }\n    // Choose rendering method based on current settings\n    if (state.isWipeEnabled && state.imageALoaded && state.imageBLoaded) {\n        // Draw wipe interface\n        drawWipeView(state, drawUI);\n    }\n    else {\n        // Draw single image or composite without wipe\n        drawSingleView(state);\n    }\n}\n/**\n * Creates a checkerboard pattern that can be used as a fill style.\n * This is more efficient than drawing individual squares and matches the single version.\n *\n * @param ctx - The canvas rendering context to create the pattern for\n * @param squareSize - Size of each square in the checkerboard (default: 10)\n * @param color1 - First color of the checkerboard (default: black)\n * @param color2 - Second color of the checkerboard (default: grey)\n * @returns A CanvasPattern object that can be used as fillStyle\n */\nfunction createCheckerboardPattern(ctx, squareSize = 10, color1 = 'black', color2 = '#808080' // grey50 to match single version\n) {\n    // Create a small canvas for the pattern\n    const patternCanvas = document.createElement('canvas');\n    patternCanvas.width = squareSize * 2;\n    patternCanvas.height = squareSize * 2;\n    const patternCtx = patternCanvas.getContext('2d');\n    if (!patternCtx)\n        return null;\n    // Draw the pattern - fill entire area with first color\n    patternCtx.fillStyle = color1;\n    patternCtx.fillRect(0, 0, squareSize * 2, squareSize * 2);\n    // Draw alternating squares with second color\n    patternCtx.fillStyle = color2;\n    patternCtx.fillRect(0, 0, squareSize, squareSize);\n    patternCtx.fillRect(squareSize, squareSize, squareSize, squareSize);\n    // Create and return the pattern\n    return ctx.createPattern(patternCanvas, 'repeat');\n}\n// Use a WeakMap to store pattern maps by context, with each map storing patterns by square size\n// WeakMap allows the patterns to be garbage collected when the context is no longer used\nconst checkerboardPatterns = new WeakMap();\n/**\n * Draws a checkerboard pattern background using efficient pattern-based rendering.\n * This matches the implementation in the single version for consistency.\n * Used to indicate transparency or as a neutral background.\n *\n * @param ctx - Canvas rendering context\n * @param width - Canvas width\n * @param height - Canvas height\n * @param offsetX - Optional X offset for pattern alignment (default: 0)\n * @param offsetY - Optional Y offset for pattern alignment (default: 0)\n * @param squareSize - Size of checkerboard squares in pixels (default: 10)\n */\nexport function drawCheckerboard(ctx, width, height, offsetX = 0, offsetY = 0, squareSize = 10) {\n    // Create a unique key for this context and square size combination\n    const patternKey = `${squareSize}`;\n    let patternMap = checkerboardPatterns.get(ctx);\n    if (!patternMap) {\n        patternMap = new Map();\n        checkerboardPatterns.set(ctx, patternMap);\n    }\n    let pattern = patternMap.get(patternKey);\n    if (!pattern) {\n        // Create a new pattern for this context and square size\n        const newPattern = createCheckerboardPattern(ctx, squareSize);\n        if (!newPattern)\n            return; // Exit if pattern creation failed\n        pattern = newPattern;\n        // Store the pattern for future use with this context and square size\n        patternMap.set(patternKey, pattern);\n    }\n    // Save the current context state\n    ctx.save();\n    // Set the pattern as fill style\n    ctx.fillStyle = pattern;\n    const patternSize = squareSize * 2;\n    // Apply the offset for pattern alignment (if any)\n    if (offsetX !== 0 || offsetY !== 0) {\n        // Use pattern size (2 * squareSize) for proper alignment\n        ctx.translate(-offsetX % patternSize, -offsetY % patternSize);\n    }\n    // Fill the entire canvas with the pattern.\n    // Add patternSize in case an offset was applied.\n    ctx.fillRect(0, 0, width + patternSize, height + patternSize);\n    // Restore the context state\n    ctx.restore();\n}\n/**\n * Draws a single view (no wipe interface).\n * This handles all composite modes when wipe is disabled.\n *\n * @param state - Component state\n */\nfunction drawSingleView(state) {\n    if (!state.ctx || !state.canvas)\n        return;\n    switch (state.compositeMode) {\n        case 'A':\n            if (state.imageALoaded && state.imageA) {\n                drawSingleImage(state, 'A');\n            }\n            break;\n        case 'B':\n            if (state.imageBLoaded && state.imageB) {\n                drawSingleImage(state, 'B');\n            }\n            break;\n        case 'Under':\n            // Draw A first, then B with alpha blending\n            if (state.imageALoaded && state.imageA) {\n                drawSingleImage(state, 'A');\n            }\n            if (state.imageBLoaded && state.imageB) {\n                state.ctx.globalAlpha = 0.5;\n                drawSingleImage(state, 'B');\n                state.ctx.globalAlpha = 1.0;\n            }\n            break;\n        case 'OnionSkin':\n            // Draw A first, then B with additive blending\n            if (state.imageALoaded && state.imageA) {\n                drawSingleImage(state, 'A');\n            }\n            if (state.imageBLoaded && state.imageB) {\n                state.ctx.globalAlpha = 0.5;\n                const originalCompositeOp = state.ctx.globalCompositeOperation;\n                state.ctx.globalCompositeOperation = 'lighter';\n                drawSingleImage(state, 'B');\n                state.ctx.globalCompositeOperation = originalCompositeOp;\n                state.ctx.globalAlpha = 1.0;\n            }\n            break;\n        case 'Diff':\n        case 'InvDiff':\n            if (state.imageALoaded && state.imageBLoaded && state.imageA && state.imageB) {\n                drawDifferenceComposite(state, state.compositeMode === 'InvDiff', 1.0);\n            }\n            break;\n    }\n}\n/**\n * Draws the wipe view with both images and wipe interface.\n * This uses the correct clipping approach: no clipping for A side,\n * proper geometric clipping for composite side.\n *\n * @param state - Component state\n * @param drawUI - Whether to draw UI elements (handles, wipe line)\n */\nfunction drawWipeView(state, drawUI = true) {\n    if (!state.ctx || !state.canvas || !state.imageALoaded || !state.imageBLoaded)\n        return;\n    const canvasWidth = state.canvas.width;\n    const canvasHeight = state.canvas.height;\n    // Calculate the wipe line\n    const wipePos = getWipePositionInCanvasCoords(state);\n    const wipeAngleRad = state.isSimpleWipe ? 0 : state.wipeAngle * (Math.PI / 180);\n    // STEP 1: Draw image A as the base layer for the entire canvas (no clipping)\n    drawSingleImage(state, 'A');\n    // STEP 2: Create clipping path for the composite side and draw composite\n    state.ctx.save();\n    // Create clipping path that represents the composite side of the wipe line\n    // This is a half-plane defined by the wipe line\n    createWipeClippingPath(state.ctx, wipePos, wipeAngleRad, canvasWidth, canvasHeight, state);\n    // Apply the clipping path\n    state.ctx.clip();\n    // STEP 3: Draw the composite in the clipped region using offscreen canvas\n    const offscreenCanvas = document.createElement('canvas');\n    offscreenCanvas.width = canvasWidth;\n    offscreenCanvas.height = canvasHeight;\n    const offscreenCtx = offscreenCanvas.getContext('2d');\n    if (offscreenCtx) {\n        // Use effective alpha - for simple wipe always use 1.0, for full wipe use slider value\n        const effectiveAlpha = state.isSimpleWipe ? 1.0 : state.wipeAlpha;\n        // Create temporary state for offscreen rendering\n        const offscreenState = {\n            ...state,\n            ctx: offscreenCtx,\n            canvas: offscreenCanvas\n        };\n        // Render composite content to offscreen canvas\n        renderCompositeContent(offscreenState, effectiveAlpha);\n        // Draw the offscreen canvas to the main canvas (in the clipped region)\n        state.ctx.globalAlpha = 1.0;\n        state.ctx.drawImage(offscreenCanvas, 0, 0);\n    }\n    // Restore the context state after clipping\n    state.ctx.restore();\n    // Draw the wipe line and UI elements only if requested\n    if (drawUI) {\n        // Draw the wipe line\n        drawWipeLine(state.ctx, wipePos, state.wipeAngle);\n        // Draw wipe UI elements - always draw translation handle, additional handles only for full wipe\n        drawWipeUIElements(state.ctx, wipePos, state.wipeAngle, state);\n    }\n}\n/**\n * Creates a clipping path for the composite side of the wipe line.\n * Clips the image B rectangle with the wipe line to get the correct polygon.\n * Result can be: full rectangle, pentagon (cut corner), trapezoid, or triangle.\n *\n * @param ctx - Canvas rendering context\n * @param wipePos - Wipe position in canvas coordinates\n * @param wipeAngleRad - Wipe angle in radians\n * @param canvasWidth - Canvas width\n * @param canvasHeight - Canvas height\n * @param state - Component state (needed for image B bounds)\n */\nexport function createWipeClippingPath(ctx, wipePos, wipeAngleRad, canvasWidth, canvasHeight, state) {\n    if (!state.imageB)\n        return;\n    // Calculate image B rectangle in canvas coordinates\n    const imageBWidth = state.imageB.width * state.scale;\n    const imageBHeight = state.imageB.height * state.scale;\n    const imageBX = state.offsetX + state.offsetBX;\n    const imageBY = state.offsetY + state.offsetBY;\n    // Define the four corners of image B rectangle\n    const rectCorners = [\n        { x: imageBX, y: imageBY }, // top-left\n        { x: imageBX + imageBWidth, y: imageBY }, // top-right\n        { x: imageBX + imageBWidth, y: imageBY + imageBHeight }, // bottom-right\n        { x: imageBX, y: imageBY + imageBHeight } // bottom-left\n    ];\n    // Calculate wipe line normal vector (pointing to composite side)\n    const normalX = Math.cos(wipeAngleRad);\n    const normalY = Math.sin(wipeAngleRad);\n    // Classify each corner: is it on the composite side of the wipe line?\n    const cornerSides = rectCorners.map(corner => {\n        const dx = corner.x - wipePos.x;\n        const dy = corner.y - wipePos.y;\n        const dotProduct = dx * normalX + dy * normalY;\n        return {\n            corner,\n            onCompositeSide: dotProduct > 0,\n            distance: dotProduct\n        };\n    });\n    // Get corners on composite side\n    const compositeCorners = cornerSides.filter(c => c.onCompositeSide).map(c => c.corner);\n    // If no corners are on composite side, no clipping needed (empty region)\n    if (compositeCorners.length === 0) {\n        // Create empty clipping path\n        ctx.beginPath();\n        ctx.rect(0, 0, 0, 0);\n        return;\n    }\n    // If all corners are on composite side, use the full rectangle\n    if (compositeCorners.length === 4) {\n        ctx.beginPath();\n        ctx.moveTo(rectCorners[0].x, rectCorners[0].y);\n        ctx.lineTo(rectCorners[1].x, rectCorners[1].y);\n        ctx.lineTo(rectCorners[2].x, rectCorners[2].y);\n        ctx.lineTo(rectCorners[3].x, rectCorners[3].y);\n        ctx.closePath();\n        return;\n    }\n    // We need to find intersections of the wipe line with rectangle edges\n    const intersections = [];\n    // Calculate wipe line direction vector\n    const lineX = -Math.sin(wipeAngleRad);\n    const lineY = Math.cos(wipeAngleRad);\n    // Check intersection with each rectangle edge\n    const edges = [\n        // Top edge: from top-left to top-right\n        { start: rectCorners[0], end: rectCorners[1] },\n        // Right edge: from top-right to bottom-right\n        { start: rectCorners[1], end: rectCorners[2] },\n        // Bottom edge: from bottom-right to bottom-left\n        { start: rectCorners[2], end: rectCorners[3] },\n        // Left edge: from bottom-left to top-left\n        { start: rectCorners[3], end: rectCorners[0] }\n    ];\n    for (const edge of edges) {\n        const intersection = findLineIntersection(wipePos.x, wipePos.y, wipePos.x + lineX, wipePos.y + lineY, edge.start.x, edge.start.y, edge.end.x, edge.end.y);\n        if (intersection &&\n            intersection.x >= Math.min(edge.start.x, edge.end.x) - 1e-6 &&\n            intersection.x <= Math.max(edge.start.x, edge.end.x) + 1e-6 &&\n            intersection.y >= Math.min(edge.start.y, edge.end.y) - 1e-6 &&\n            intersection.y <= Math.max(edge.start.y, edge.end.y) + 1e-6) {\n            intersections.push(intersection);\n        }\n    }\n    // Remove duplicate intersections\n    const uniqueIntersections = [];\n    for (const intersection of intersections) {\n        const isDuplicate = uniqueIntersections.some(existing => Math.abs(existing.x - intersection.x) < 1e-6 &&\n            Math.abs(existing.y - intersection.y) < 1e-6);\n        if (!isDuplicate) {\n            uniqueIntersections.push(intersection);\n        }\n    }\n    // Create the clipping polygon\n    ctx.beginPath();\n    if (uniqueIntersections.length >= 2) {\n        // Build the polygon by combining composite corners and intersections\n        // We need to traverse the rectangle boundary and include the right points\n        const allPoints = [];\n        // Add composite corners\n        for (const corner of compositeCorners) {\n            allPoints.push({ ...corner, type: 'corner' });\n        }\n        // Add intersections\n        for (const intersection of uniqueIntersections) {\n            allPoints.push({ ...intersection, type: 'intersection' });\n        }\n        // Sort points to form a proper polygon\n        // For simplicity, we'll use a different approach: trace the rectangle boundary\n        const polygonPoints = [];\n        // Start from first composite corner and trace boundary\n        if (compositeCorners.length > 0) {\n            // Add all composite corners\n            polygonPoints.push(...compositeCorners);\n            // Add intersections\n            polygonPoints.push(...uniqueIntersections);\n            // Sort points by angle from centroid to create proper polygon\n            const centroidX = polygonPoints.reduce((sum, p) => sum + p.x, 0) / polygonPoints.length;\n            const centroidY = polygonPoints.reduce((sum, p) => sum + p.y, 0) / polygonPoints.length;\n            polygonPoints.sort((a, b) => {\n                const angleA = Math.atan2(a.y - centroidY, a.x - centroidX);\n                const angleB = Math.atan2(b.y - centroidY, b.x - centroidX);\n                return angleA - angleB;\n            });\n        }\n        // Draw the polygon\n        if (polygonPoints.length > 0) {\n            ctx.moveTo(polygonPoints[0].x, polygonPoints[0].y);\n            for (let i = 1; i < polygonPoints.length; i++) {\n                ctx.lineTo(polygonPoints[i].x, polygonPoints[i].y);\n            }\n            ctx.closePath();\n        }\n    }\n    else {\n        // Fallback: just use composite corners if we can't find intersections\n        if (compositeCorners.length > 0) {\n            ctx.moveTo(compositeCorners[0].x, compositeCorners[0].y);\n            for (let i = 1; i < compositeCorners.length; i++) {\n                ctx.lineTo(compositeCorners[i].x, compositeCorners[i].y);\n            }\n            ctx.closePath();\n        }\n    }\n}\n/**\n * Finds the intersection point of two lines defined by two points each.\n * Returns null if lines are parallel or don't intersect.\n */\nfunction findLineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {\n    const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (Math.abs(denom) < 1e-10) {\n        return null; // Lines are parallel\n    }\n    const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;\n    return {\n        x: x1 + t * (x2 - x1),\n        y: y1 + t * (y2 - y1)\n    };\n}\n/**\n * Renders composite content based on the current mode.\n * This matches the original renderCompositeContent function.\n *\n * @param state - Component state (can be offscreen)\n * @param alpha - Alpha value for blending\n */\nexport function renderCompositeContent(state, alpha) {\n    if (!state.ctx)\n        return;\n    switch (state.compositeMode) {\n        case 'Under':\n            // Draw A first, then B with alpha blending\n            drawSingleImage(state, 'A');\n            state.ctx.globalAlpha = alpha;\n            drawSingleImage(state, 'B');\n            state.ctx.globalAlpha = 1.0;\n            break;\n        case 'OnionSkin': {\n            // Draw A first, then B with additive blending\n            drawSingleImage(state, 'A');\n            state.ctx.globalAlpha = alpha;\n            const originalCompositeOp = state.ctx.globalCompositeOperation;\n            state.ctx.globalCompositeOperation = 'lighter';\n            drawSingleImage(state, 'B');\n            state.ctx.globalCompositeOperation = originalCompositeOp;\n            state.ctx.globalAlpha = 1.0;\n            break;\n        }\n        case 'A':\n            drawSingleImage(state, 'A');\n            break;\n        case 'B':\n            drawSingleImage(state, 'B');\n            break;\n        case 'Diff':\n        case 'InvDiff':\n            drawDifferenceComposite(state, state.compositeMode === 'InvDiff', alpha);\n            break;\n    }\n}\n/**\n * Draws a single image (A or B) to the canvas.\n *\n * @param state - Component state\n * @param imageType - Which image to draw ('A' or 'B')\n */\nexport function drawSingleImage(state, imageType) {\n    if (!state.ctx)\n        return;\n    const image = imageType === 'A' ? state.imageA : state.imageB;\n    const mipMaps = imageType === 'A' ? state.imageAMipMaps : state.imageBMipMaps;\n    const offsetX = imageType === 'A' ? state.offsetAX : state.offsetBX;\n    const offsetY = imageType === 'A' ? state.offsetAY : state.offsetBY;\n    if (!image)\n        return;\n    // Calculate image position\n    const imageX = state.offsetX + offsetX;\n    const imageY = state.offsetY + offsetY;\n    const imageWidth = image.width * state.scale;\n    const imageHeight = image.height * state.scale;\n    // Use mip-maps if available for better quality\n    if (mipMaps && mipMaps.length > 0) {\n        renderImageWithMipMaps(state.ctx, image, mipMaps, imageX, imageY, imageWidth, imageHeight, state.scale);\n    }\n    else {\n        // Fallback to direct rendering\n        // Use nearest neighbor interpolation when zoomed in (scale >= 1)\n        // Use bilinear interpolation when zoomed out (scale < 1)\n        state.ctx.imageSmoothingEnabled = state.scale < 1;\n        state.ctx.drawImage(image, 0, 0, image.width, image.height, imageX, imageY, imageWidth, imageHeight);\n    }\n}\n/**\n * Renders an image with mip-mapping for better quality at different zoom levels.\n *\n * @param ctx - Canvas rendering context\n * @param originalImage - Original full-resolution image\n * @param mipMaps - Mip-map pyramid\n * @param destX - Destination X coordinate\n * @param destY - Destination Y coordinate\n * @param destWidth - Destination width\n * @param destHeight - Destination height\n * @param scale - Current scale factor\n */\nfunction renderImageWithMipMaps(ctx, originalImage, mipMaps, destX, destY, destWidth, destHeight, scale) {\n    // Select appropriate mip level based on scale\n    let mipLevel = 0;\n    let currentScale = scale;\n    while (currentScale < 0.5 && mipLevel < mipMaps.length - 1) {\n        currentScale *= 2;\n        mipLevel++;\n    }\n    const imageToUse = mipLevel === 0 ? originalImage : mipMaps[mipLevel - 1];\n    // Use nearest neighbor interpolation when zoomed in (scale >= 1)\n    // Use bilinear interpolation when zoomed out (scale < 1)\n    ctx.imageSmoothingEnabled = scale < 1;\n    ctx.drawImage(imageToUse, 0, 0, imageToUse.width, imageToUse.height, destX, destY, destWidth, destHeight);\n}\n/**\n * Draws the wipe line itself.\n * Centers the line segment on the projection of canvas center onto the wipe line.\n *\n * @param ctx - Canvas rendering context\n * @param wipePos - Wipe position in canvas coordinates (not used for centering)\n * @param wipeAngleDeg - Wipe angle in degrees\n */\nexport function drawWipeLine(ctx, wipePos, wipeAngleDeg) {\n    ctx.save();\n    // Set styles for the wipe line\n    ctx.strokeStyle = 'white';\n    ctx.lineWidth = 1;\n    ctx.shadowColor = 'black';\n    ctx.shadowBlur = 2;\n    // Calculate canvas center\n    const canvasCenterX = ctx.canvas.width / 2;\n    const canvasCenterY = ctx.canvas.height / 2;\n    // Convert angle to radians and calculate wipe line direction vector\n    const wipeAngleRad = wipeAngleDeg * (Math.PI / 180);\n    const lineX = -Math.sin(wipeAngleRad);\n    const lineY = Math.cos(wipeAngleRad);\n    // Project canvas center onto the wipe line\n    // Vector from wipe position to canvas center\n    const toCenterX = canvasCenterX - wipePos.x;\n    const toCenterY = canvasCenterY - wipePos.y;\n    // Project this vector onto the wipe line direction\n    const projectionLength = toCenterX * lineX + toCenterY * lineY;\n    // Find the projection point on the wipe line\n    const projectionX = wipePos.x + projectionLength * lineX;\n    const projectionY = wipePos.y + projectionLength * lineY;\n    // Calculate line endpoints centered on the projection point\n    // Use a length that ensures the line extends across the entire canvas\n    const lineLength = Math.max(ctx.canvas.width, ctx.canvas.height) * 2;\n    const x1 = projectionX - lineX * lineLength;\n    const y1 = projectionY - lineY * lineLength;\n    const x2 = projectionX + lineX * lineLength;\n    const y2 = projectionY + lineY * lineLength;\n    // Draw the wipe line\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n    ctx.restore();\n}\n/**\n * Draws the wipe UI elements (handles and controls).\n *\n * @param ctx - Canvas rendering context\n * @param wipePos - Wipe position in canvas coordinates\n * @param wipeAngleDeg - Wipe angle in degrees\n * @param state - Component state\n */\nfunction drawWipeUIElements(ctx, wipePos, wipeAngleDeg, state) {\n    ctx.save();\n    // Set styles for UI elements - match original exactly\n    ctx.strokeStyle = 'white';\n    ctx.lineWidth = 1;\n    ctx.shadowColor = 'black';\n    ctx.shadowBlur = 2;\n    ctx.fillStyle = 'white';\n    // Draw translation handle (center dot)\n    ctx.beginPath();\n    ctx.arc(wipePos.x, wipePos.y, UI_CONSTANTS.TRANSLATION_HANDLE_RADIUS, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.stroke();\n    // If using the full wipe interface (not simple wipe), draw additional controls\n    if (!state.isSimpleWipe) {\n        // Calculate rotation handle position\n        const rotHandlePos = calculateRotationHandlePosition(wipePos, wipeAngleDeg);\n        // Draw line to rotation handle\n        ctx.beginPath();\n        ctx.moveTo(wipePos.x, wipePos.y);\n        ctx.lineTo(rotHandlePos.x, rotHandlePos.y);\n        ctx.stroke();\n        // Draw rotation handle\n        ctx.beginPath();\n        ctx.arc(rotHandlePos.x, rotHandlePos.y, UI_CONSTANTS.ROTATION_HANDLE_RADIUS, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.stroke();\n        // Draw alpha arc - match original arc extent\n        const wipeAngleRad = wipeAngleDeg * (Math.PI / 180);\n        const startAngle = wipeAngleRad - (UI_CONSTANTS.ALPHA_ARC_START_ANGLE * Math.PI / 180);\n        const endAngle = wipeAngleRad - (UI_CONSTANTS.ALPHA_ARC_END_ANGLE * Math.PI / 180);\n        ctx.beginPath();\n        ctx.arc(wipePos.x, wipePos.y, UI_CONSTANTS.ALPHA_ARC_RADIUS, startAngle, endAngle);\n        ctx.stroke();\n        // Calculate alpha slider position\n        const alphaSliderPos = calculateAlphaSliderPosition(wipePos, wipeAngleDeg, state.wipeAlpha);\n        // Draw alpha slider\n        ctx.beginPath();\n        ctx.arc(alphaSliderPos.x, alphaSliderPos.y, UI_CONSTANTS.ALPHA_HANDLE_RADIUS, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.stroke();\n    }\n    ctx.restore();\n}\n/**\n * Draws difference composite between two images.\n *\n * @param state - Component state\n * @param inverted - Whether to invert the difference\n * @param alpha - Alpha value for blending (0-1)\n */\nfunction drawDifferenceComposite(state, inverted, alpha = 1.0) {\n    if (!state.ctx || !state.imageA || !state.imageB)\n        return;\n    // Create an offscreen canvas for the difference calculation\n    const offCanvas = document.createElement('canvas');\n    offCanvas.width = state.canvas.width;\n    offCanvas.height = state.canvas.height;\n    const offCtx = offCanvas.getContext('2d');\n    if (!offCtx)\n        return;\n    if (inverted) {\n        // Fill with white for inverted difference\n        offCtx.fillStyle = 'white';\n        offCtx.fillRect(0, 0, offCanvas.width, offCanvas.height);\n    }\n    // Draw image B\n    drawSingleImage({ ...state, ctx: offCtx, canvas: offCanvas }, 'B');\n    // Set difference blend mode\n    offCtx.globalCompositeOperation = 'difference';\n    // Draw image A\n    drawSingleImage({ ...state, ctx: offCtx, canvas: offCanvas }, 'A');\n    if (inverted) {\n        // Invert the difference\n        offCtx.globalCompositeOperation = 'difference';\n        offCtx.fillStyle = 'white';\n        offCtx.fillRect(0, 0, offCanvas.width, offCanvas.height);\n    }\n    // Draw the result to the main canvas with alpha\n    state.ctx.globalAlpha = alpha;\n    state.ctx.drawImage(offCanvas, 0, 0);\n    state.ctx.globalAlpha = 1.0; // Reset alpha\n}\n//# sourceMappingURL=drawing.js.map","/**\n * Magnifier functionality for the Image Comparison Element.\n * This module provides configurable zoom magnification functionality that shows\n * a detailed view of the area around the mouse cursor.\n */\nimport { drawSingleImage, renderCompositeContent, createWipeClippingPath, drawWipeLine, drawCheckerboard } from './drawing';\nimport { getWipePositionInCanvasCoords } from './coordinates';\n/**\n * Updates the magnifier position and content.\n *\n * @param magnifierContainer - The container element for the magnifier\n * @param magnifierCanvas - The canvas element for rendering the magnified content\n * @param x - X coordinate of the mouse pointer in canvas coordinates\n * @param y - Y coordinate of the mouse pointer in canvas coordinates\n * @param state - Element state\n */\nexport function updateMagnifier(magnifierContainer, magnifierCanvas, x, y, state) {\n    // Use configurable magnifier properties from state (with fallbacks for backward compatibility)\n    const magnifierRadius = state.magnifierRadius || 200;\n    const zoom = state.magnifierZoomFactor || 8;\n    const borderSize = state.magnifierBorderSize || 2;\n    // Skip magnifier update if zoom factor is <= 0 (disabled)\n    if (zoom <= 0)\n        return;\n    // Position magnifier container - center it on the mouse position, accounting for border\n    magnifierContainer.style.left = `${x - magnifierRadius - borderSize}px`;\n    magnifierContainer.style.top = `${y - magnifierRadius - borderSize}px`;\n    // Ensure the magnifier canvas has the correct size (diameter = radius * 2)\n    const magnifierDiameter = magnifierRadius * 2;\n    if (magnifierCanvas.width !== magnifierDiameter || magnifierCanvas.height !== magnifierDiameter) {\n        magnifierCanvas.width = magnifierDiameter;\n        magnifierCanvas.height = magnifierDiameter;\n    }\n    // Get the 2D rendering context for the magnifier canvas\n    const magCtx = magnifierCanvas.getContext('2d');\n    if (!magCtx)\n        return;\n    // Clear previous content and set default black background\n    magCtx.fillStyle = 'black';\n    magCtx.fillRect(0, 0, magnifierDiameter, magnifierDiameter);\n    // Create a circular clipping path for the magnifier content\n    magCtx.save();\n    magCtx.beginPath();\n    magCtx.arc(magnifierRadius, magnifierRadius, magnifierRadius, 0, Math.PI * 2);\n    magCtx.clip();\n    // Calculate the world coordinates that should be at the center of the magnifier\n    // This is the key to proper magnifier centering\n    const worldX = (x - state.offsetX) / state.scale;\n    const worldY = (y - state.offsetY) / state.scale;\n    // Calculate the offset needed to center the world coordinates in the magnifier\n    const magnifierOffsetX = magnifierRadius - worldX * state.scale * zoom;\n    const magnifierOffsetY = magnifierRadius - worldY * state.scale * zoom;\n    // Draw checkerboard background if enabled\n    if (state.isCheckerboard) {\n        // Calculate offset to make magnifier checkerboard align with main canvas pattern\n        // The magnifier should show the checkerboard as if we're looking at the main canvas\n        // through a magnifying glass - the pattern should be continuous\n        // The mouse position (x, y) represents where we're looking on the main canvas\n        // The magnifier shows this area zoomed in, so the checkerboard pattern should\n        // align as if this area was extracted from the main canvas\n        const offsetX = x - magnifierRadius;\n        const offsetY = y - magnifierRadius;\n        // Use configurable square size from component state\n        const squareSize = state.checkerboardSquareSize || 10;\n        drawCheckerboard(magCtx, magnifierDiameter, magnifierDiameter, offsetX, offsetY, squareSize);\n    }\n    // Create a temporary state for magnifier rendering with adjusted offsets\n    const magnifierState = {\n        canvas: magnifierCanvas,\n        ctx: magCtx,\n        imageA: state.imageA,\n        imageB: state.imageB,\n        imageAData: state.imageAData,\n        imageBData: state.imageBData,\n        imageAMipMaps: state.imageAMipMaps,\n        imageBMipMaps: state.imageBMipMaps,\n        imageALoaded: state.imageALoaded,\n        imageBLoaded: state.imageBLoaded,\n        scale: state.scale * zoom,\n        offsetX: magnifierOffsetX,\n        offsetY: magnifierOffsetY,\n        offsetAX: state.offsetAX * zoom,\n        offsetAY: state.offsetAY * zoom,\n        offsetBX: state.offsetBX * zoom,\n        offsetBY: state.offsetBY * zoom,\n        wipePositionInImageACoords: state.wipePositionInImageACoords,\n        wipeAngle: state.wipeAngle,\n        wipeAlpha: state.wipeAlpha,\n        isWipeEnabled: state.isWipeEnabled,\n        isSimpleWipe: state.isSimpleWipe,\n        isCheckerboard: state.isCheckerboard,\n        compositeMode: state.compositeMode,\n        showHelp: state.showHelp,\n        magnifierRadius: state.magnifierRadius,\n        magnifierZoomFactor: state.magnifierZoomFactor\n    };\n    // Render the appropriate content based on the current mode\n    if (state.compositeMode === 'A') {\n        // Show only image A\n        if (state.imageA && state.imageALoaded) {\n            drawSingleImage(magnifierState, 'A');\n        }\n    }\n    else if (state.compositeMode === 'B') {\n        // Show only image B\n        if (state.imageB && state.imageBLoaded) {\n            drawSingleImage(magnifierState, 'B');\n        }\n    }\n    else {\n        // Composite modes (Under, OnionSkin, Diff, InvDiff)\n        if (state.isWipeEnabled) {\n            // Apply wipe effect using the same logic as the main drawing function\n            const wipeCanvasCoords = getWipePositionInCanvasCoords(magnifierState);\n            // STEP 1: Draw image A as the base layer (no clipping)\n            if (state.imageA && state.imageALoaded) {\n                drawSingleImage(magnifierState, 'A');\n            }\n            // STEP 2: Create clipping path for the composite side and draw composite\n            magCtx.save();\n            // Create clipping path that represents the composite side of the wipe line\n            createWipeClippingPath(magCtx, wipeCanvasCoords, state.wipeAngle * Math.PI / 180, magnifierDiameter, magnifierDiameter, magnifierState);\n            // Apply the clipping path\n            magCtx.clip();\n            // STEP 3: Draw the composite in the clipped region\n            if (state.imageA && state.imageALoaded && state.imageB && state.imageBLoaded) {\n                // Use effective alpha - for simple wipe always use 1.0, for full wipe use slider value\n                const effectiveAlpha = state.isSimpleWipe ? 1.0 : state.wipeAlpha;\n                // Create temporary state for composite rendering with effective alpha\n                const compositeState = {\n                    ...magnifierState,\n                    wipeAlpha: effectiveAlpha\n                };\n                renderCompositeContent(compositeState, effectiveAlpha);\n            }\n            magCtx.restore();\n            // STEP 4: Draw wipe line\n            drawWipeLine(magCtx, wipeCanvasCoords, state.wipeAngle * Math.PI / 180);\n        }\n        else {\n            // No wipe - render composite content directly\n            if (state.imageA && state.imageALoaded && state.imageB && state.imageBLoaded) {\n                renderCompositeContent(magnifierState, state.wipeAlpha);\n            }\n        }\n    }\n    // Restore the context to remove the clipping path\n    magCtx.restore();\n    // Draw crosshair in the center of the magnifier\n    magCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';\n    magCtx.lineWidth = 1;\n    // Horizontal line\n    magCtx.beginPath();\n    magCtx.moveTo(0, magnifierRadius);\n    magCtx.lineTo(magnifierDiameter, magnifierRadius);\n    magCtx.stroke();\n    // Vertical line\n    magCtx.beginPath();\n    magCtx.moveTo(magnifierRadius, 0);\n    magCtx.lineTo(magnifierRadius, magnifierDiameter);\n    magCtx.stroke();\n}\n//# sourceMappingURL=magnifier.js.map","/**\n * Creates a mip-map pyramid for an image to improve rendering quality at different zoom levels.\n *\n * Mip-mapping is a technique that pre-generates multiple versions of an image at different\n * resolutions. Each level in the pyramid is half the size of the previous level. This allows\n * for better quality rendering when zoomed out, as the appropriate resolution can be selected\n * based on the current zoom level.\n *\n * @param image - The original image to create mip-maps from\n * @returns A promise that resolves to an array of images forming the mip-map pyramid\n */\nexport function createMipMaps(image) {\n    return new Promise((resolve) => {\n        // Start with the original image as level 0\n        const mipMaps = [image];\n        // Track the current dimensions\n        let width = image.width;\n        let height = image.height;\n        // If the image is very small, don't create mip-maps\n        if (width < 4 || height < 4) {\n            resolve(mipMaps);\n            return;\n        }\n        /**\n         * Recursive function to create the next mip level\n         * Each level is half the size of the previous level\n         *\n         * @returns void\n         */\n        const createNextLevel = () => {\n            // Stop if we've reached a very small size\n            if (width <= 1 && height <= 1) {\n                resolve(mipMaps);\n                return;\n            }\n            // Calculate next mip level size (half size)\n            width = Math.max(1, Math.floor(width / 2));\n            height = Math.max(1, Math.floor(height / 2));\n            // Create a temporary canvas for downsampling\n            const canvas = document.createElement('canvas');\n            canvas.width = width;\n            canvas.height = height;\n            const ctx = canvas.getContext('2d');\n            // Handle case where canvas context couldn't be created\n            if (!ctx) {\n                resolve(mipMaps);\n                return;\n            }\n            // Use bilinear interpolation for better quality downsampling\n            ctx.imageSmoothingEnabled = true;\n            // Draw the previous level image at half size\n            ctx.drawImage(mipMaps[mipMaps.length - 1], 0, 0, width, height);\n            // Convert canvas to image\n            const img = new Image();\n            // When the image loads, add it to the pyramid and continue\n            img.onload = () => {\n                mipMaps.push(img);\n                createNextLevel(); // Create next level recursively\n            };\n            // Set the image source to the canvas data\n            img.src = canvas.toDataURL();\n        };\n        // Start creating mip levels\n        createNextLevel();\n    });\n}\n//# sourceMappingURL=mip-mapping.js.map","/**\n * UI element constants for wipe interface.\n * Contains all the sizing and positioning constants used for drawing UI elements.\n */\nexport const UI_CONSTANTS = {\n    // Handle radii\n    TRANSLATION_HANDLE_RADIUS: 6,\n    ROTATION_HANDLE_RADIUS: 4,\n    ALPHA_HANDLE_RADIUS: 4,\n    // Distances and positions\n    ROTATION_HANDLE_DISTANCE: 60,\n    ALPHA_ARC_RADIUS: 40,\n    // Alpha arc angles (in degrees)\n    ALPHA_ARC_START_ANGLE: 70,\n    ALPHA_ARC_END_ANGLE: 20,\n};\n/**\n * Calculates the position of the rotation handle based on wipe position and angle.\n *\n * @param wipePos - The center position of the wipe effect\n * @param wipeAngleDeg - The rotation angle of the wipe in degrees\n * @returns Position coordinates for the rotation handle\n */\nexport function calculateRotationHandlePosition(wipePos, wipeAngleDeg) {\n    const wipeAngleRad = wipeAngleDeg * (Math.PI / 180);\n    return {\n        x: wipePos.x + Math.cos(wipeAngleRad) * UI_CONSTANTS.ROTATION_HANDLE_DISTANCE,\n        y: wipePos.y + Math.sin(wipeAngleRad) * UI_CONSTANTS.ROTATION_HANDLE_DISTANCE\n    };\n}\n/**\n * Calculates the position of the alpha slider handle based on wipe position, angle and alpha value.\n *\n * @param wipePos - The center position of the wipe effect\n * @param wipeAngleDeg - The rotation angle of the wipe in degrees\n * @param wipeAlpha - The alpha/opacity value between 0 and 1\n * @returns Position coordinates for the alpha slider handle\n */\nexport function calculateAlphaSliderPosition(wipePos, wipeAngleDeg, wipeAlpha) {\n    const wipeAngleRad = wipeAngleDeg * (Math.PI / 180);\n    const alphaAngle = wipeAngleRad - ((UI_CONSTANTS.ALPHA_ARC_END_ANGLE + (1 - wipeAlpha) * (UI_CONSTANTS.ALPHA_ARC_START_ANGLE - UI_CONSTANTS.ALPHA_ARC_END_ANGLE)) * Math.PI / 180);\n    return {\n        x: wipePos.x + Math.cos(alphaAngle) * UI_CONSTANTS.ALPHA_ARC_RADIUS,\n        y: wipePos.y + Math.sin(alphaAngle) * UI_CONSTANTS.ALPHA_ARC_RADIUS\n    };\n}\n//# sourceMappingURL=ui-constants.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Image Comparison Element\n *\n * A custom HTML element that provides image comparison functionality with wipe interface,\n * multiple composite modes, and interactive controls. This component encapsulates all\n * the functionality of the original single-page application into a reusable element\n * that can be embedded multiple times on any web page.\n *\n * @example\n * ```html\n * <image-comparison\n *   image-a=\"path/to/imageA.jpg\"\n *   image-b=\"path/to/imageB.jpg\"\n *   display-mode=\"Under\"\n *   wipe-mode=\"simple\">\n * </image-comparison>\n * ```\n */\nimport { createMipMaps } from './mip-mapping';\nimport { calculatePSNRForImages } from './analysis';\nimport { canvasToImageCoords, getWipePositionInCanvasCoords } from './coordinates';\nimport { draw as drawCanvas } from './drawing';\nimport { updateMagnifier } from './magnifier';\nimport { UI_CONSTANTS, calculateRotationHandlePosition, calculateAlphaSliderPosition } from './ui-constants';\n/**\n * Custom HTML element for image comparison functionality.\n *\n * This element provides a complete image comparison interface with support for:\n * - Multiple composite modes (Under, OnionSkin, Diff, InvDiff, A, B)\n * - Interactive wipe interface (simple and full modes)\n * - Zoom and pan functionality\n * - Magnifier with 8x zoom\n * - Keyboard shortcuts\n * - Drag and drop image loading\n * - PSNR calculation\n *\n * The component maintains its own isolated state and can be used multiple times\n * on the same page without interference.\n */\nexport class ImageComparisonElement extends HTMLElement {\n    /**\n     * Constructor - initializes the web component\n     */\n    constructor() {\n        super();\n        // Element state - mirrors the original global state structure but isolated per instance\n        this.state = {\n            /** The main canvas element */\n            canvas: null,\n            /** The 2D rendering context of the canvas */\n            ctx: null,\n            /** The first image (A) to compare */\n            imageA: null,\n            /** The second image (B) to compare */\n            imageB: null,\n            /** Pixel data for image A */\n            imageAData: null,\n            /** Pixel data for image B */\n            imageBData: null,\n            /** Mip-map pyramid for image A for efficient rendering at different zoom levels */\n            imageAMipMaps: null,\n            /** Mip-map pyramid for image B for efficient rendering at different zoom levels */\n            imageBMipMaps: null,\n            /** Whether image A has been loaded successfully */\n            imageALoaded: false,\n            /** Whether image B has been loaded successfully */\n            imageBLoaded: false,\n            /** Current zoom scale factor */\n            scale: 1,\n            /** Global X offset for both images */\n            offsetX: 0,\n            /** Global Y offset for both images */\n            offsetY: 0,\n            /** Additional X offset specific to image A */\n            offsetAX: 0,\n            /** Additional Y offset specific to image A */\n            offsetAY: 0,\n            /** Additional X offset specific to image B */\n            offsetBX: 0,\n            /** Additional Y offset specific to image B */\n            offsetBY: 0,\n            /** Whether the wipe interface is enabled */\n            isWipeEnabled: true,\n            /** Whether to use the simple vertical wipe (true) or the full wipe interface (false) */\n            isSimpleWipe: false,\n            /** Angle of the wipe line in degrees */\n            wipeAngle: 0,\n            /** Position of the wipe line center in image A coordinates */\n            wipePositionInImageACoords: { x: 0, y: 0 },\n            /** Alpha blending value for the wipe interface (0-1) */\n            wipeAlpha: 1,\n            /** Whether to show the checkerboard background */\n            isCheckerboard: false,\n            /** Current composite mode for blending images */\n            compositeMode: 'Under',\n            /** Whether to show the help screen */\n            showHelp: true,\n            /** Radius of the magnifier in pixels (default: 200) */\n            magnifierRadius: 200,\n            /** Zoom factor for the magnifier (default: 8) */\n            magnifierZoomFactor: 8,\n            /** Border size of the magnifier in pixels (default: 2) */\n            magnifierBorderSize: 2,\n            /** Size of checkerboard squares in pixels (default: 10) */\n            checkerboardSquareSize: 10\n        };\n        // Additional component-specific state not in the original global state\n        /** Previous wipe angle, stored when switching to simple wipe mode or other modes */\n        this.previousWipeAngle = 0;\n        /** Previous wipe alpha, stored when switching to simple wipe mode or other modes */\n        this.previousWipeAlpha = 1;\n        /** Previous composite mode, stored when switching to A or B mode */\n        this.lastCompositeMode = 'Under';\n        // Interaction state variables (from original index.ts)\n        /** Whether the user is currently dragging */\n        this.isDragging = false;\n        /** X coordinate where dragging started */\n        this.dragStartX = 0;\n        /** Y coordinate where dragging started */\n        this.dragStartY = 0;\n        /** Last recorded mouse X position */\n        this.lastMouseX = 0;\n        /** Last recorded mouse Y position */\n        this.lastMouseY = 0;\n        /** Whether the magnifier is currently visible */\n        this.showMagnifier = false;\n        /** Which handle is currently being dragged (null if none) */\n        this.activeHandle = null;\n        /** Whether help was manually toggled (vs auto-shown) */\n        this.manuallyToggledHelp = false;\n        /** Which side of the wipe is being dragged when shift is held */\n        this.dragSide = null;\n        /** Accumulated movement for pixel-perfect positioning */\n        this.accumulatedDX = 0;\n        /** Accumulated movement for pixel-perfect positioning */\n        this.accumulatedDY = 0;\n        // Create shadow DOM for complete encapsulation\n        this.shadow = this.attachShadow({ mode: 'open' });\n        // Create the component structure\n        this.createComponentStructure();\n        // Initialize the component\n        this.initialize();\n    }\n    /**\n     * Defines which attributes to observe for changes.\n     * When these attributes change, attributeChangedCallback will be called.\n     */\n    static get observedAttributes() {\n        return [\n            'image-a',\n            'image-b',\n            'display-mode',\n            'wipe-mode',\n            'wipe-position-x',\n            'wipe-position-y',\n            'wipe-angle',\n            'wipe-alpha',\n            'magnifier-radius',\n            'magnifier-zoom-factor',\n            'magnifier-border-size',\n            'checkerboard-square-size'\n        ];\n    }\n    /**\n     * Called when the element is connected to the DOM.\n     * Sets up initial state and event listeners.\n     */\n    connectedCallback() {\n        // Process initial attributes\n        this.processAttributes();\n        // Set initial canvas size\n        this.updateCanvasSize();\n        // Add resize observer to handle container size changes\n        const resizeObserver = new ResizeObserver(() => {\n            this.updateCanvasSize();\n        });\n        resizeObserver.observe(this);\n        // Show help screen initially if no images are loaded\n        this.updateHelpScreenVisibility();\n    }\n    /**\n     * Helper method to get image-specific DOM elements and state properties.\n     *\n     * This method provides a centralized way to access all DOM elements and state\n     * properties associated with a specific image (A or B), eliminating repetitive\n     * conditional logic throughout the component. It returns a comprehensive object\n     * containing all image-related references:\n     *\n     * **State Properties:**\n     * - **isLoaded**: Boolean indicating whether the image is currently loaded\n     * - **image**: The HTMLImageElement containing the loaded image data\n     * - **imageData**: The ImageData object for pixel-level access and analysis\n     *\n     * **DOM Elements:**\n     * - **coordsRgbaElement**: Span element displaying coordinates and RGBA values\n     * - **filenameElement**: Span element showing the loaded image filename\n     * - **uploadElement**: Div element representing the upload box UI\n     * - **fileInputElement**: Hidden input element for file selection\n     *\n     * **Usage Pattern:**\n     * This method eliminates the need for repetitive conditional statements like:\n     * ```typescript\n     * const element = imageType === 'A' ? this.elementA : this.elementB;\n     * ```\n     *\n     * Instead, it provides a clean destructuring pattern:\n     * ```typescript\n     * const { isLoaded, image, coordsRgbaElement } = this.getImageElements(imageType);\n     * ```\n     *\n     * **Type Safety:**\n     * The method maintains type safety by using the ImageType parameter to\n     * determine which set of elements to return, ensuring consistent access\n     * patterns across the component.\n     *\n     * Factorized to reduce code duplication in image-related operations and\n     * provide a consistent interface for accessing image-specific resources.\n     *\n     * @param imageType - The image identifier ('A' or 'B') to get elements for\n     * @returns Object containing all DOM elements and state properties for the specified image\n     *\n     * @example\n     * ```typescript\n     * // Get all elements for image A\n     * const { isLoaded, image, coordsRgbaElement } = this.getImageElements('A');\n     *\n     * // Use in conditional logic\n     * if (isLoaded && image) {\n     *     coordsRgbaElement.textContent = `[${x},${y}]=(${r},${g},${b},${a})`;\n     * }\n     * ```\n     *\n     * @see {@link updateImageInfo} - Primary consumer of this method\n     */\n    getImageElements(imageType) {\n        // Determine if we're working with image A or B\n        const isImageA = imageType === 'A';\n        // Return object with all image-specific elements and state properties\n        return {\n            // State properties for the specified image\n            isLoaded: isImageA ? this.state.imageALoaded : this.state.imageBLoaded,\n            image: isImageA ? this.state.imageA : this.state.imageB,\n            imageData: isImageA ? this.state.imageAData : this.state.imageBData,\n            // DOM elements for the specified image\n            coordsRgbaElement: isImageA ? this.coordsRgbaA : this.coordsRgbaB,\n            filenameElement: isImageA ? this.filenameA : this.filenameB,\n            uploadElement: isImageA ? this.uploadA : this.uploadB,\n            fileInputElement: isImageA ? this.fileInputA : this.fileInputB\n        };\n    }\n    /**\n     * Helper method to parse and set numeric attribute values with validation.\n     *\n     * This method provides centralized handling for all numeric attributes in the\n     * web component, eliminating code duplication and ensuring consistent parsing\n     * and validation behavior. It implements a comprehensive attribute processing\n     * workflow:\n     *\n     * **Input Validation:**\n     * - Performs null/undefined checks to handle missing attribute values\n     * - Uses parseFloat for robust numeric parsing that handles various formats\n     * - Validates parsed values using isNaN to reject invalid numeric inputs\n     * - Provides early return for invalid inputs to prevent error propagation\n     *\n     * **Attribute Processing:**\n     * - Maps attribute names to their corresponding setter methods\n     * - Maintains type safety through proper method delegation\n     * - Supports all numeric configuration attributes of the component\n     *\n     * **Supported Attributes:**\n     * - **wipe-position-x**: X coordinate for wipe line positioning\n     * - **wipe-position-y**: Y coordinate for wipe line positioning\n     * - **wipe-angle**: Rotation angle for wipe line in degrees\n     * - **wipe-alpha**: Alpha blending factor (0-1) for wipe operations\n     * - **magnifier-radius**: Radius of the magnification circle in pixels\n     * - **magnifier-zoom-factor**: Zoom multiplier for magnification (0 to disable)\n     *\n     * **Error Handling:**\n     * The method gracefully handles invalid inputs by returning early without\n     * throwing exceptions, ensuring robust component behavior even with malformed\n     * attribute values.\n     *\n     * Factorized to reduce code duplication in attributeChangedCallback and\n     * provide consistent numeric attribute processing across the component.\n     *\n     * @param name - The name of the numeric attribute to process\n     * @param value - The string value of the attribute to parse and apply\n     *\n     * @example\n     * ```typescript\n     * // Called internally during attribute change processing\n     * this.setNumericAttribute('magnifier-radius', '150');\n     * this.setNumericAttribute('wipe-alpha', '0.5');\n     * this.setNumericAttribute('wipe-angle', '45');\n     * ```\n     *\n     * @see {@link attributeChangedCallback} - Uses this method for numeric attribute processing\n     */\n    setNumericAttribute(name, value) {\n        // Early return for null or undefined values\n        if (!value)\n            return;\n        // Parse the string value to a floating-point number\n        const numValue = parseFloat(value);\n        // Validate the parsed number and return early if invalid\n        if (isNaN(numValue))\n            return;\n        // Delegate to the appropriate setter method based on attribute name\n        switch (name) {\n            case 'wipe-position-x':\n                this.setWipePositionX(numValue);\n                break;\n            case 'wipe-position-y':\n                this.setWipePositionY(numValue);\n                break;\n            case 'wipe-angle':\n                this.setWipeAngle(numValue);\n                break;\n            case 'wipe-alpha':\n                this.setWipeAlpha(numValue);\n                break;\n            case 'magnifier-radius':\n                this.setMagnifierRadius(numValue);\n                break;\n            case 'magnifier-zoom-factor':\n                this.setMagnifierZoomFactor(numValue);\n                break;\n            case 'magnifier-border-size':\n                this.setMagnifierBorderSize(numValue);\n                break;\n            case 'checkerboard-square-size':\n                this.setCheckerboardSquareSize(numValue);\n                break;\n        }\n    }\n    /**\n     * Called when observed attributes change.\n     * Updates the component state based on attribute changes.\n     */\n    attributeChangedCallback(name, oldValue, newValue) {\n        if (oldValue === newValue)\n            return;\n        switch (name) {\n            case 'image-a':\n                if (newValue)\n                    this.loadImage(newValue, 'A');\n                break;\n            case 'image-b':\n                if (newValue)\n                    this.loadImage(newValue, 'B');\n                break;\n            case 'display-mode':\n                if (newValue)\n                    this.setDisplayMode(newValue);\n                break;\n            case 'wipe-mode':\n                this.setWipeMode(newValue === 'simple');\n                break;\n            case 'wipe-position-x':\n            case 'wipe-position-y':\n            case 'wipe-angle':\n            case 'wipe-alpha':\n            case 'magnifier-radius':\n            case 'magnifier-zoom-factor':\n            case 'magnifier-border-size':\n            case 'checkerboard-square-size':\n                this.setNumericAttribute(name, newValue);\n                break;\n        }\n    }\n    /**\n     * Creates the component structure in the shadow DOM.\n     * This replicates the exact HTML structure from the original index.html\n     * but encapsulated within the shadow DOM for isolation.\n     */\n    createComponentStructure() {\n        // Add styles to shadow DOM - copied and adapted from original styles.css\n        const style = document.createElement('style');\n        style.textContent = this.getComponentStyles();\n        this.shadow.appendChild(style);\n        // Create the exact same structure as the original HTML\n        const container = document.createElement('div');\n        container.className = 'image-comparison-container';\n        container.innerHTML = `\n            <div id=\"canvas-container\">\n                <canvas id=\"imageCanvas\"></canvas>\n                <div id=\"magnifier-container\" class=\"hidden\">\n                    <canvas id=\"magnifierCanvas\"></canvas>\n                </div>\n                <div id=\"drag-message\"></div>\n                <div id=\"help-screen\">\n                    <h1>Image Comparison Element</h1>\n                    <p>Upload images by clicking on the A or B boxes in the bottom banner</p>\n                    <p>or drag and drop image files anywhere in the application:</p>\n                    <ul>\n                        <li>Drag and drop a single image anywhere (except B box): loads as image A</li>\n                        <li>Drag and drop multiple images anywhere: loads first as A, second as B</li>\n                        <li>Drag and drop directly onto A or B boxes: loads to that specific slot</li>\n                    </ul>\n                    <p>Use mouse wheel to zoom, click and drag to move both images.</p>\n                    <p>Use Shift+click and drag to move only one image (A or B).</p>\n                    <p>Press \"v\" for simple wipe, \"w\" for full wipe interface.</p>\n                    <p>Press \"u\", \"o\", \"d\", \"i\" to change composite modes.</p>\n                    <p>Press \"a\" to show only image A, \"b\" to show only image B.</p>\n                    <p>Press \"c\" to toggle checkerboard background.</p>\n                    <p>Press \"r\" to reset view (position, zoom, wipe settings).</p>\n                    <p>Press \"h\" or \"?\" to toggle this help screen.</p>\n                    <p id=\"magnifier-help\">Hold Ctrl to show magnifying glass at mouse pointer position.</p>\n                </div>\n            </div>\n            <div id=\"bottom-banner\">\n                <div class=\"banner-section\">\n                    <div id=\"upload-container\">\n                        <div id=\"upload-a\" class=\"upload-box\">\n                            <span>A: </span>\n                            <span id=\"filename-a\">No file</span>\n                            <span id=\"coords-rgba-a\"></span>\n                            <input type=\"file\" id=\"file-a\" accept=\"image/*\" style=\"display:none\">\n                        </div>\n                        <div id=\"upload-b\" class=\"upload-box\">\n                            <span>B: </span>\n                            <span id=\"filename-b\">No file</span>\n                            <span id=\"coords-rgba-b\"></span>\n                            <input type=\"file\" id=\"file-b\" accept=\"image/*\" style=\"display:none\">\n                        </div>\n                    </div>\n                </div>\n                <div class=\"banner-section\">\n                    <div id=\"psnr-info\">PSNR: -</div>\n                </div>\n                <div class=\"banner-section\">\n                    <div id=\"mode-container\">\n                        <span>Mode: </span>\n                        <span id=\"mode-info\">Under</span>\n                    </div>\n                </div>\n                <div class=\"banner-section\">\n                    <div id=\"help-info\">Help: press \"h\"</div>\n                </div>\n            </div>\n        `;\n        this.shadow.appendChild(container);\n    }\n    /**\n     * Returns the CSS styles for the component.\n     * These styles are adapted from the original styles.css but scoped to the component.\n     */\n    getComponentStyles() {\n        return `\n            :host {\n                display: block;\n                width: 100%;\n                height: 100%;\n                min-height: 400px;\n                font-family: Arial, sans-serif;\n                color: #fff;\n                background-color: #333;\n                position: relative;\n                overflow: hidden;\n            }\n            \n            .image-comparison-container {\n                width: 100%;\n                height: 100%;\n                display: flex;\n                flex-direction: column;\n                position: relative;\n            }\n            \n            #canvas-container {\n                flex: 1;\n                position: relative;\n                overflow: hidden;\n            }\n            \n            #imageCanvas {\n                width: 100%;\n                height: 100%;\n                display: block;\n                background-color: black;\n                cursor: move;\n            }\n            \n            #magnifier-container {\n                position: absolute;\n                width: var(--magnifier-diameter, 400px);\n                height: var(--magnifier-diameter, 400px);\n                border-radius: 50%;\n                overflow: hidden;\n                pointer-events: none;\n                box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);\n                border: 2px solid white;\n                cursor: none;\n                will-change: transform;\n                transform: translateZ(0);\n                backface-visibility: hidden;\n                z-index: 1000;\n                background-color: black;\n            }\n            \n            #magnifierCanvas {\n                width: 100%;\n                height: 100%;\n                display: block;\n            }\n            \n            .hidden {\n                display: none;\n            }\n            \n            #drag-message {\n                position: absolute;\n                top: 50%;\n                left: 50%;\n                transform: translate(-50%, -50%);\n                background-color: rgba(0, 0, 0, 0.7);\n                color: white;\n                padding: 15px 25px;\n                border-radius: 8px;\n                font-size: 18px;\n                z-index: 1000;\n                pointer-events: none;\n                box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);\n                border: 1px solid rgba(255, 255, 255, 0.3);\n                max-width: 80%;\n                text-align: center;\n                opacity: 0;\n                transition: opacity 0.3s;\n            }\n            \n            #help-screen {\n                position: absolute;\n                top: 0;\n                left: 0;\n                right: 0;\n                bottom: 40px;\n                background-color: rgba(0, 0, 0, 0.6);\n                color: white;\n                display: flex;\n                flex-direction: column;\n                justify-content: center;\n                align-items: center;\n                z-index: 100;\n                text-align: center;\n                padding: 15px;\n                box-sizing: border-box;\n                overflow-y: auto;\n            }\n            \n            #help-screen h1 {\n                font-size: 18px;\n                margin-bottom: 15px;\n                margin-top: 0;\n            }\n            \n            #help-screen p {\n                font-size: 12px;\n                margin: 3px 0;\n                max-width: 90%;\n                line-height: 1.3;\n            }\n            \n            #help-screen ul {\n                text-align: left;\n                max-width: 90%;\n                font-size: 12px;\n                margin: 8px 0;\n                padding-left: 20px;\n                line-height: 1.3;\n            }\n            \n            #help-screen li {\n                margin: 2px 0;\n            }\n            \n            #magnifier-help {\n                font-size: 12px;\n                margin: 8px 0 3px 0;\n                max-width: 90%;\n                line-height: 1.3;\n            }\n            \n            #bottom-banner {\n                height: 40px;\n                background-color: #222;\n                display: flex;\n                align-items: center;\n                padding: 0 10px;\n                box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.3);\n                font-size: 12px;\n            }\n            \n            .banner-section {\n                margin-right: 10px;\n                display: flex;\n                align-items: center;\n            }\n            \n            #upload-container {\n                display: flex;\n            }\n            \n            .upload-box {\n                background-color: #555;\n                padding: 5px 10px;\n                margin-right: 10px;\n                border-radius: 3px;\n                cursor: pointer;\n                transition: background-color 0.2s;\n                white-space: nowrap;\n                font-size: 12px;\n                min-width: 150px;\n                flex-shrink: 0;\n            }\n            \n            .upload-box:hover {\n                background-color: #777;\n            }\n            \n            .info-section {\n                font-size: 12px;\n                color: #fff;\n            }\n            \n            #image-a-info, #image-b-info {\n                margin-right: 5px;\n            }\n        `;\n    }\n    /**\n     * Initialize the component after DOM structure is created.\n     * Sets up DOM references, canvas context, and event listeners.\n     */\n    initialize() {\n        // Get references to DOM elements within shadow DOM\n        this.initDomReferences();\n        // Initialize the canvas and context\n        this.initCanvas();\n        // Set up event listeners\n        this.setupEventListeners();\n    }\n    /**\n     * Initialize references to DOM elements within the shadow DOM.\n     * This allows us to interact with the encapsulated elements.\n     */\n    initDomReferences() {\n        this.state.canvas = this.shadow.getElementById('imageCanvas');\n        this.magnifierContainer = this.shadow.getElementById('magnifier-container');\n        this.magnifierCanvas = this.shadow.getElementById('magnifierCanvas');\n        this.dragMessage = this.shadow.getElementById('drag-message');\n        this.uploadA = this.shadow.getElementById('upload-a');\n        this.uploadB = this.shadow.getElementById('upload-b');\n        this.fileInputA = this.shadow.getElementById('file-a');\n        this.fileInputB = this.shadow.getElementById('file-b');\n        this.filenameA = this.shadow.getElementById('filename-a');\n        this.filenameB = this.shadow.getElementById('filename-b');\n        this.coordsRgbaA = this.shadow.getElementById('coords-rgba-a');\n        this.coordsRgbaB = this.shadow.getElementById('coords-rgba-b');\n        this.psnrInfo = this.shadow.getElementById('psnr-info');\n        this.modeInfo = this.shadow.getElementById('mode-info');\n        this.helpScreen = this.shadow.getElementById('help-screen');\n        this.magnifierHelp = this.shadow.getElementById('magnifier-help');\n    }\n    /**\n     * Initialize canvas and set up the rendering context.\n     * This sets up the canvas for drawing operations.\n     */\n    initCanvas() {\n        if (!this.state.canvas) {\n            console.error('Canvas element not found');\n            return;\n        }\n        // Get the 2D rendering context with alpha disabled for better performance\n        this.state.ctx = this.state.canvas.getContext('2d', { alpha: false });\n        if (!this.state.ctx) {\n            console.error('Failed to get canvas context');\n            return;\n        }\n    }\n    /**\n     * Process attributes when the element is connected or attributes change.\n     * This reads the initial attribute values and applies them to the component.\n     */\n    processAttributes() {\n        const imageA = this.getAttribute('image-a');\n        const imageB = this.getAttribute('image-b');\n        if (imageA)\n            this.loadImage(imageA, 'A');\n        if (imageB)\n            this.loadImage(imageB, 'B');\n        const displayMode = this.getAttribute('display-mode');\n        if (displayMode)\n            this.setDisplayMode(displayMode);\n        const wipeMode = this.getAttribute('wipe-mode');\n        if (wipeMode)\n            this.setWipeMode(wipeMode === 'simple');\n        const wipeX = this.getAttribute('wipe-position-x');\n        const wipeY = this.getAttribute('wipe-position-y');\n        if (wipeX)\n            this.setWipePositionX(parseFloat(wipeX));\n        if (wipeY)\n            this.setWipePositionY(parseFloat(wipeY));\n        const wipeAngle = this.getAttribute('wipe-angle');\n        if (wipeAngle)\n            this.setWipeAngle(parseFloat(wipeAngle));\n        const wipeAlpha = this.getAttribute('wipe-alpha');\n        if (wipeAlpha)\n            this.setWipeAlpha(parseFloat(wipeAlpha));\n        // Process magnifier attributes\n        const magnifierRadius = this.getAttribute('magnifier-radius');\n        if (magnifierRadius) {\n            this.setMagnifierRadius(parseFloat(magnifierRadius));\n        }\n        const magnifierZoomFactor = this.getAttribute('magnifier-zoom-factor');\n        if (magnifierZoomFactor) {\n            this.setMagnifierZoomFactor(parseFloat(magnifierZoomFactor));\n        }\n        const magnifierBorderSize = this.getAttribute('magnifier-border-size');\n        if (magnifierBorderSize) {\n            this.setMagnifierBorderSize(parseFloat(magnifierBorderSize));\n        }\n        const checkerboardSquareSize = this.getAttribute('checkerboard-square-size');\n        if (checkerboardSquareSize) {\n            this.setCheckerboardSquareSize(parseFloat(checkerboardSquareSize));\n        }\n    }\n    /**\n     * Update canvas size based on container size.\n     * This ensures the canvas matches the component's dimensions.\n     */\n    updateCanvasSize() {\n        if (!this.state.canvas)\n            return;\n        const width = this.clientWidth;\n        const height = this.clientHeight - 40; // Account for bottom banner\n        if (width > 0 && height > 0) {\n            this.state.canvas.width = width;\n            this.state.canvas.height = height;\n            if (this.magnifierCanvas) {\n                this.magnifierCanvas.width = 400;\n                this.magnifierCanvas.height = 400;\n            }\n            // Redraw with new size\n            this.draw();\n        }\n    }\n    /**\n     * Update help screen visibility based on whether images are loaded and showHelp state.\n     * Shows help screen when fewer than 2 images are loaded OR when manually toggled on.\n     * Auto-hides when both images are loaded (unless manually toggled on).\n     */\n    updateHelpScreenVisibility() {\n        const imagesLoaded = (this.state.imageALoaded ? 1 : 0) + (this.state.imageBLoaded ? 1 : 0);\n        // Auto-hide help when both images are loaded for the first time\n        if (imagesLoaded >= 2) {\n            // If help was auto-shown (not manually toggled), hide it and set showHelp to false\n            if (this.state.showHelp && !this.manuallyToggledHelp) {\n                this.state.showHelp = false;\n                this.helpScreen.style.display = 'none';\n            }\n            // If manually toggled on, keep it visible\n            else if (this.state.showHelp) {\n                this.helpScreen.style.display = 'flex';\n            }\n            // If manually toggled off, keep it hidden\n            else {\n                this.helpScreen.style.display = 'none';\n            }\n        }\n        // Show help screen if fewer than 2 images are loaded\n        else {\n            this.helpScreen.style.display = 'flex';\n            // Reset manual toggle flag when auto-showing\n            this.manuallyToggledHelp = false;\n        }\n        // Update magnifier help visibility\n        this.updateMagnifierHelpVisibility();\n    }\n    /**\n     * Updates the visibility of the magnifier help text based on the current zoom factor.\n     * Hides the help text when magnifier is disabled (zoom factor <= 0).\n     */\n    updateMagnifierHelpVisibility() {\n        if (this.magnifierHelp) {\n            if (this.state.magnifierZoomFactor && this.state.magnifierZoomFactor > 0) {\n                this.magnifierHelp.style.display = 'block';\n                // Update the help text to include the current zoom factor\n                this.magnifierHelp.textContent = `Hold Ctrl to show magnifying glass (${this.state.magnifierZoomFactor}x zoom) at mouse pointer position.`;\n            }\n            else {\n                this.magnifierHelp.style.display = 'none';\n            }\n        }\n    }\n    /**\n     * Shared implementation for loading images A and B.\n     *\n     * @param url - The URL to load the image from (can be web URL or blob URL)\n     * @param imageType - Which image slot to load into ('A' or 'B')\n     * @param filename - Optional filename to display in UI (used for uploaded files)\n     *\n     * @returns Promise that resolves when image loading and processing is complete\n     *\n     * @throws Will reject the promise if image loading fails or processing encounters errors\n     *\n     * @remarks\n     * This method performs the complete image loading pipeline:\n     * 1. Image loading via HTML Image element\n     * 2. Canvas-based pixel data extraction for analysis\n     * 3. Mip-map generation for performance optimization\n     * 4. UI updates with proper filename handling\n     * 5. Layout adjustments and redraw operations\n     *\n     * The imageType parameter determines which state properties are updated,\n     * allowing the same logic to handle both image A and image B loading.\n     */\n    async loadImage(url, imageType, filename) {\n        // Log the loading operation for debugging and monitoring\n        console.log(`Loading image ${imageType} from URL:`, url);\n        // Create new Image element for loading - this provides better control than direct canvas loading\n        const img = new Image();\n        // Return a Promise to handle the asynchronous image loading process\n        return new Promise((resolve, reject) => {\n            // Configure success handler - called when image loads successfully\n            img.onload = async () => {\n                try {\n                    // Store the loaded image in component state for rendering operations\n                    // Update the appropriate state properties based on imageType\n                    if (imageType === 'A') {\n                        this.state.imageA = img;\n                        this.state.imageALoaded = true;\n                    }\n                    else {\n                        this.state.imageB = img;\n                        this.state.imageBLoaded = true;\n                    }\n                    // Create temporary canvas for pixel data extraction\n                    // This is necessary for pixel-level analysis operations like PSNR calculation\n                    const tempCanvas = document.createElement('canvas');\n                    // Set canvas dimensions to match the loaded image exactly\n                    // This ensures pixel-perfect data extraction without scaling artifacts\n                    tempCanvas.width = img.width;\n                    tempCanvas.height = img.height;\n                    const tempCtx = tempCanvas.getContext('2d');\n                    // Verify canvas context creation succeeded before proceeding\n                    if (tempCtx) {\n                        // Draw the image to canvas at original size for pixel data extraction\n                        // This creates the ImageData needed for analysis operations\n                        tempCtx.drawImage(img, 0, 0);\n                        // Extract pixel data for analysis operations (PSNR, color sampling, etc.)\n                        // ImageData provides direct access to RGBA values for each pixel\n                        // Store in the appropriate state property based on imageType\n                        if (imageType === 'A') {\n                            this.state.imageAData = tempCtx.getImageData(0, 0, img.width, img.height);\n                        }\n                        else {\n                            this.state.imageBData = tempCtx.getImageData(0, 0, img.width, img.height);\n                        }\n                    }\n                    // Generate mip-maps asynchronously for efficient rendering at different zoom levels\n                    // Mip-maps provide pre-scaled versions of the image to improve performance\n                    // and visual quality when zoomed out\n                    const mipMaps = await createMipMaps(img);\n                    if (imageType === 'A') {\n                        this.state.imageAMipMaps = mipMaps;\n                    }\n                    else {\n                        this.state.imageBMipMaps = mipMaps;\n                    }\n                    // Update filename display with intelligent fallback handling\n                    // Priority: provided filename > URL extraction > default fallback\n                    // This fixes the \"Uploaded file\" issue for drag-and-drop operations\n                    const displayFilename = filename || this.extractFilename(url);\n                    const filenameElement = imageType === 'A' ? this.filenameA : this.filenameB;\n                    filenameElement.textContent = displayFilename;\n                    // Update help screen visibility based on current loading state\n                    // The help screen should hide when images are successfully loaded\n                    this.updateHelpScreenVisibility();\n                    // Perform automatic layout adjustments for optimal viewing experience\n                    // Center the wipe position to provide balanced comparison view\n                    this.centerWipePosition();\n                    // Fit images to viewport for optimal initial viewing\n                    // This ensures both images are visible and properly scaled\n                    this.fitImagesToViewport();\n                    // Trigger complete redraw with the newly loaded image\n                    // This updates all visual elements including composite modes\n                    this.draw();\n                    // Calculate and update PSNR if both images are loaded\n                    // PSNR provides quantitative comparison metrics\n                    this.updatePSNR();\n                    // Resolve the promise to indicate successful completion\n                    resolve();\n                }\n                catch (error) {\n                    // Handle any errors during image processing (mip-map generation, etc.)\n                    console.error(`Error processing image ${imageType}:`, error);\n                    reject(error);\n                }\n            };\n            // Configure error handler for image loading failures\n            img.onerror = (error) => {\n                // Log the error for debugging purposes\n                console.error(`Error loading image ${imageType}:`, error);\n                // Update UI to show error state with helpful filename information\n                // Extract filename from URL for better error messaging\n                const filenameElement = imageType === 'A' ? this.filenameA : this.filenameB;\n                filenameElement.textContent = \"Error loading \" + (url.split('/').pop() || url);\n                // Reject the promise to indicate loading failure\n                reject(error);\n            };\n            // Configure CORS handling for cross-origin images\n            // This allows loading images from different domains when properly configured\n            img.crossOrigin = 'anonymous';\n            // Initiate the image loading process by setting the source URL\n            // This triggers the onload or onerror handlers defined above\n            img.src = url;\n        });\n    }\n    /**\n     * Set the display mode for image composition.\n     * Updates the composite mode and redraws the canvas.\n     */\n    setDisplayMode(mode) {\n        const previousMode = this.state.compositeMode;\n        // Store previous mode if switching to A or B\n        if ((mode === 'A' || mode === 'B') &&\n            this.state.compositeMode !== 'A' && this.state.compositeMode !== 'B') {\n            this.lastCompositeMode = this.state.compositeMode;\n            // Store wipe settings when switching to A or B mode\n            if (this.state.isWipeEnabled) {\n                this.previousWipeAngle = this.state.wipeAngle;\n                this.previousWipeAlpha = this.state.wipeAlpha;\n            }\n        }\n        this.state.compositeMode = mode;\n        this.modeInfo.textContent = mode;\n        // When switching to A or B mode, disable wipe\n        if (mode === 'A' || mode === 'B') {\n            this.state.isWipeEnabled = false;\n        }\n        else {\n            // When switching back to a composite mode, restore wipe\n            this.state.isWipeEnabled = true;\n            // Only restore wipe settings if coming from A or B mode\n            // If already in a composite mode, keep current wipe settings\n            if (previousMode === 'A' || previousMode === 'B') {\n                if (this.state.isSimpleWipe) {\n                    this.state.wipeAngle = 0; // Simple wipe always has angle 0\n                }\n                else {\n                    this.state.wipeAngle = this.previousWipeAngle;\n                    this.state.wipeAlpha = this.previousWipeAlpha;\n                }\n            }\n            // If switching between composite modes, keep current wipe settings unchanged\n        }\n        this.draw();\n    }\n    /**\n     * Set the wipe mode (simple or full).\n     * Updates the wipe interface type and preserves angle and alpha settings.\n     */\n    setWipeMode(isSimple) {\n        // Store the current wipe angle and alpha if switching to simple mode\n        if (isSimple && !this.state.isSimpleWipe) {\n            this.previousWipeAngle = this.state.wipeAngle;\n            this.previousWipeAlpha = this.state.wipeAlpha;\n        }\n        this.state.isWipeEnabled = true;\n        this.state.isSimpleWipe = isSimple;\n        // If switching to simple mode, set angle to 0\n        if (isSimple) {\n            this.state.wipeAngle = 0;\n            // Alpha remains the same in simple mode\n        }\n        else {\n            // If switching back to full mode, restore the previous angle and alpha\n            this.state.wipeAngle = this.previousWipeAngle;\n            this.state.wipeAlpha = this.previousWipeAlpha;\n        }\n        // If we're in A or B mode, restore the previous composite mode\n        if (this.state.compositeMode === 'A' || this.state.compositeMode === 'B') {\n            this.state.compositeMode = this.lastCompositeMode;\n            this.modeInfo.textContent = this.lastCompositeMode;\n        }\n        this.draw();\n    }\n    /**\n     * Set the X position of the wipe line in image A coordinates.\n     */\n    setWipePositionX(x) {\n        this.state.wipePositionInImageACoords.x = x;\n        this.draw();\n    }\n    /**\n     * Set the Y position of the wipe line in image A coordinates.\n     */\n    setWipePositionY(y) {\n        this.state.wipePositionInImageACoords.y = y;\n        this.draw();\n    }\n    /**\n     * Set the angle of the wipe line in degrees.\n     */\n    setWipeAngle(angle) {\n        this.state.wipeAngle = angle;\n        this.previousWipeAngle = angle;\n        this.draw();\n    }\n    /**\n     * Set the alpha blending factor for the wipe interface.\n     */\n    setWipeAlpha(alpha) {\n        alpha = Math.max(0, Math.min(1, alpha));\n        this.state.wipeAlpha = alpha;\n        this.previousWipeAlpha = alpha; // Store for mode switching\n        this.draw();\n    }\n    /**\n     * Sets the magnifier radius in pixels.\n     *\n     * @param radius - The radius of the magnifier in pixels\n     */\n    setMagnifierRadius(radius) {\n        if (radius <= 0)\n            return; // Prevent invalid values\n        this.state.magnifierRadius = radius;\n        // Update CSS variable for magnifier diameter (radius * 2)\n        this.style.setProperty('--magnifier-diameter', `${radius * 2}px`);\n        // Update magnifier if it's currently visible\n        if (this.showMagnifier && this.lastMouseX !== 0 && this.lastMouseY !== 0) {\n            this.updateMagnifier(this.lastMouseX, this.lastMouseY);\n        }\n    }\n    /**\n     * Sets the magnifier zoom factor.\n     *\n     * @param zoomFactor - The zoom factor for the magnifier (e.g., 8 for 8x zoom)\n     *                    - Set to 0 or negative to disable the magnifier functionality\n     */\n    setMagnifierZoomFactor(zoomFactor) {\n        this.state.magnifierZoomFactor = zoomFactor;\n        // Update the help text to reflect the current zoom factor or hide it if disabled\n        this.updateMagnifierHelpVisibility();\n        // If zoom factor is <= 0, disable magnifier functionality\n        if (zoomFactor <= 0 && this.showMagnifier) {\n            this.showMagnifier = false;\n            this.magnifierContainer.classList.add('hidden');\n        }\n        // Otherwise update magnifier if it's currently visible\n        else if (zoomFactor > 0 && this.showMagnifier && this.lastMouseX !== 0 && this.lastMouseY !== 0) {\n            this.updateMagnifier(this.lastMouseX, this.lastMouseY);\n        }\n    }\n    /**\n     * Sets the magnifier border size.\n     *\n     * @param borderSize - Border size of the magnifier in pixels\n     *                   - Must be non-negative (0 or positive)\n     *                   - Typical values: 0-5 pixels\n     *                   - Default: 2 pixels\n     */\n    setMagnifierBorderSize(borderSize) {\n        // Validate border size (must be non-negative)\n        if (borderSize < 0) {\n            console.warn('Magnifier border size must be non-negative, using default value of 2');\n            borderSize = 2;\n        }\n        this.state.magnifierBorderSize = borderSize;\n        // Update magnifier if it's currently visible\n        if (this.showMagnifier && this.lastMouseX !== 0 && this.lastMouseY !== 0) {\n            this.updateMagnifier(this.lastMouseX, this.lastMouseY);\n        }\n    }\n    /**\n     * Sets the checkerboard square size.\n     *\n     * @param squareSize - Size of checkerboard squares in pixels\n     *                   - Must be positive (minimum 1 pixel)\n     *                   - Typical values: 5-20 pixels\n     *                   - Default: 10 pixels\n     */\n    setCheckerboardSquareSize(squareSize) {\n        // Validate square size (must be positive)\n        if (squareSize <= 0) {\n            console.warn('Checkerboard square size must be positive, using default value of 10');\n            squareSize = 10;\n        }\n        this.state.checkerboardSquareSize = squareSize;\n        // Redraw if checkerboard is currently visible\n        if (this.state.isCheckerboard) {\n            this.draw();\n        }\n    }\n    /**\n     * Center the wipe position on the canvas.\n     * Converts canvas center coordinates to image A coordinates.\n     */\n    centerWipePosition() {\n        if (!this.state.canvas)\n            return;\n        // Get the center of the canvas in canvas coordinates\n        const canvasCenterX = this.state.canvas.width / 2;\n        const canvasCenterY = this.state.canvas.height / 2;\n        // Convert canvas center to image A coordinates\n        const imageCoords = this.canvasToImageCoords(canvasCenterX, canvasCenterY, 'A');\n        // Update wipe position in image A coordinates\n        this.state.wipePositionInImageACoords.x = imageCoords.x;\n        this.state.wipePositionInImageACoords.y = imageCoords.y;\n        // Update attributes to reflect the change\n        this.setAttribute('wipe-position-x', imageCoords.x.toString());\n        this.setAttribute('wipe-position-y', imageCoords.y.toString());\n        // Redraw with the new wipe position\n        this.draw();\n    }\n    /**\n     * Fit images to viewport by adjusting scale and position.\n     * Ensures images are visible and properly centered.\n     */\n    fitImagesToViewport() {\n        if (!this.state.canvas || (!this.state.imageALoaded && !this.state.imageBLoaded))\n            return;\n        // Get image dimensions\n        const imageWidth = this.state.imageALoaded ? this.state.imageA.width :\n            (this.state.imageBLoaded ? this.state.imageB.width : 0);\n        const imageHeight = this.state.imageALoaded ? this.state.imageA.height :\n            (this.state.imageBLoaded ? this.state.imageB.height : 0);\n        if (imageWidth === 0 || imageHeight === 0)\n            return;\n        // Calculate scale to fit\n        const scaleX = this.state.canvas.width / imageWidth;\n        const scaleY = this.state.canvas.height / imageHeight;\n        // Use the smaller scale to ensure the entire image fits\n        this.state.scale = Math.min(scaleX, scaleY) * 0.9; // 90% to leave some margin\n        // Center the images\n        this.state.offsetX = (this.state.canvas.width - imageWidth * this.state.scale) / 2;\n        this.state.offsetY = (this.state.canvas.height - imageHeight * this.state.scale) / 2;\n    }\n    /**\n     * Update PSNR display using the component's isolated state.\n     */\n    updatePSNR() {\n        const psnrText = calculatePSNRForImages(this.state.imageAData, this.state.imageBData, this.state.imageA, this.state.imageB, this.state.offsetAX, this.state.offsetAY, this.state.offsetBX, this.state.offsetBY, this.state.scale);\n        this.psnrInfo.textContent = psnrText;\n    }\n    /**\n     * Sets up canvas mouse and wheel event listeners for image interaction.\n     *\n     * This method configures all canvas-related event handling within the web component,\n     * enabling users to interact with the image comparison interface through mouse\n     * and wheel operations. It establishes the complete canvas interaction system:\n     *\n     * **Mouse Event Handling:**\n     * - **Mouse Down**: Initiates drag operations for image panning and wipe control\n     * - **Mouse Move**: Handles active dragging, cursor tracking, and coordinate updates\n     * - **Mouse Up**: Terminates drag operations and finalizes interactions\n     * - **Mouse Leave**: Ensures drag operations are properly terminated when cursor exits canvas\n     *\n     * **Wheel Event Handling:**\n     * - Configures zoom functionality with passive event prevention\n     * - Enables smooth zooming centered on the mouse cursor position\n     * - Maintains proper event handling for cross-browser compatibility\n     *\n     * **Component Integration:**\n     * - Includes null safety check to prevent errors during initialization\n     * - Properly binds event handlers to maintain component context\n     * - Integrates with the component's state management system\n     *\n     * **Event Handler Binding:**\n     * All event handlers are bound to the component instance to ensure proper\n     * access to component state and methods during event processing.\n     *\n     * Factorized to reduce code duplication in setupEventListeners and provide\n     * centralized canvas event configuration with proper error handling.\n     *\n     * @example\n     * ```typescript\n     * // Called during component initialization after canvas is available\n     * this.setupCanvasEventListeners();\n     * ```\n     *\n     * @see {@link handleMouseDown} - Processes mouse down events for drag initiation\n     * @see {@link handleMouseMove} - Handles mouse movement for dragging and tracking\n     * @see {@link handleMouseUp} - Terminates drag operations\n     * @see {@link handleWheel} - Processes wheel events for zoom functionality\n     */\n    setupCanvasEventListeners() {\n        // Ensure canvas is available before setting up event listeners\n        if (!this.state.canvas)\n            return;\n        // Configure mouse down events for drag operation initiation\n        this.state.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));\n        // Configure mouse move events for dragging and coordinate tracking\n        this.state.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));\n        // Configure mouse up events for drag operation termination\n        this.state.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));\n        // Configure mouse leave events to ensure drag operations end when cursor exits\n        this.state.canvas.addEventListener('mouseleave', this.handleMouseUp.bind(this));\n        // Configure wheel events for zoom functionality with passive prevention\n        this.state.canvas.addEventListener('wheel', this.handleWheel.bind(this), { passive: false });\n    }\n    /**\n     * Sets up file upload event listeners for both image A and B upload boxes.\n     *\n     * This method configures the file upload user interface by establishing\n     * event listeners for both image A and image B upload boxes within the\n     * web component. It handles the complete file upload workflow:\n     *\n     * **Click Event Handling:**\n     * - Configures upload box click events to trigger hidden file input dialogs\n     * - Provides intuitive user interaction by making upload boxes clickable\n     * - Maintains consistent behavior between both A and B upload boxes\n     *\n     * **File Selection Processing:**\n     * - Sets up change event listeners on hidden file input elements\n     * - Delegates file processing to specialized handler methods\n     * - Ensures proper binding of event handler context to the component instance\n     *\n     * **Component Integration:**\n     * - Integrates with the component's shadow DOM structure\n     * - Maintains encapsulation by using component instance methods\n     * - Provides consistent file upload behavior across component instances\n     *\n     * This method eliminates code duplication by centralizing the setup logic\n     * that would otherwise be repeated for both upload boxes, while maintaining\n     * the specialized behavior required for each image slot.\n     *\n     * Factorized to reduce code duplication in setupEventListeners and provide\n     * a centralized location for file upload configuration within the component.\n     *\n     * @example\n     * ```typescript\n     * // Called during component initialization\n     * this.setupFileUploadListeners();\n     * ```\n     *\n     * @see {@link handleFileInputA} - Handles file selection for image A\n     * @see {@link handleFileInputB} - Handles file selection for image B\n     */\n    setupFileUploadListeners() {\n        // Configure upload box click handlers to trigger file selection dialogs\n        this.uploadA.addEventListener('click', () => this.fileInputA.click());\n        this.uploadB.addEventListener('click', () => this.fileInputB.click());\n        // Configure file input change handlers with proper context binding\n        this.fileInputA.addEventListener('change', this.handleFileInputA.bind(this));\n        this.fileInputB.addEventListener('change', this.handleFileInputB.bind(this));\n    }\n    /**\n     * Set up event listeners for the component.\n     * This includes file uploads, canvas interactions, drag and drop, and keyboard events.\n     */\n    setupEventListeners() {\n        if (!this.state.canvas)\n            return;\n        // File upload event listeners - factorized setup\n        this.setupFileUploadListeners();\n        // Canvas mouse event listeners - factorized setup\n        this.setupCanvasEventListeners();\n        // Drag and drop event listeners\n        this.addEventListener('dragover', this.handleDragOver.bind(this));\n        this.addEventListener('drop', this.handleDrop.bind(this));\n        // Keyboard event listeners - only when this component has focus\n        this.addEventListener('keydown', this.handleKeyDown.bind(this));\n        this.addEventListener('keyup', this.handleKeyUp.bind(this));\n        // Make the component focusable\n        this.tabIndex = 0;\n        // Focus on mouse enter to capture keyboard events\n        this.addEventListener('mouseenter', () => this.focus());\n    }\n    /**\n     * Handle mouse down events on the canvas.\n     * Starts dragging operations and handle interactions.\n     */\n    handleMouseDown(e) {\n        e.preventDefault();\n        // Get mouse position relative to canvas\n        const rect = this.state.canvas.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n        // Reset accumulated movement values\n        this.accumulatedDX = 0;\n        this.accumulatedDY = 0;\n        // Check if clicking on wipe UI elements\n        if (this.state.isWipeEnabled && this.state.imageALoaded && this.state.imageBLoaded) {\n            const wipePos = getWipePositionInCanvasCoords(this.state);\n            // Check translation handle (center dot)\n            const distToTranslation = Math.sqrt(Math.pow(x - wipePos.x, 2) +\n                Math.pow(y - wipePos.y, 2));\n            if (distToTranslation <= UI_CONSTANTS.TRANSLATION_HANDLE_RADIUS) {\n                this.activeHandle = 'translation';\n                this.dragStartX = x;\n                this.dragStartY = y;\n                this.state.canvas.style.cursor = 'grabbing';\n                return;\n            }\n            // For full wipe interface, check additional handles\n            if (!this.state.isSimpleWipe) {\n                // Check rotation handle\n                const { x: rotX, y: rotY } = calculateRotationHandlePosition(wipePos, this.state.wipeAngle);\n                const distToRotation = Math.sqrt(Math.pow(x - rotX, 2) +\n                    Math.pow(y - rotY, 2));\n                if (distToRotation <= UI_CONSTANTS.ROTATION_HANDLE_RADIUS) {\n                    this.activeHandle = 'rotation';\n                    this.dragStartX = x;\n                    this.dragStartY = y;\n                    this.state.canvas.style.cursor = 'grabbing';\n                    return;\n                }\n                // Check alpha handle\n                const alphaSliderPos = calculateAlphaSliderPosition(wipePos, this.state.wipeAngle, this.state.wipeAlpha);\n                const alphaX = alphaSliderPos.x;\n                const alphaY = alphaSliderPos.y;\n                const distToAlpha = Math.sqrt(Math.pow(x - alphaX, 2) +\n                    Math.pow(y - alphaY, 2));\n                if (distToAlpha <= UI_CONSTANTS.ALPHA_HANDLE_RADIUS) {\n                    this.activeHandle = 'alpha';\n                    this.dragStartX = x;\n                    this.dragStartY = y;\n                    this.state.canvas.style.cursor = 'grabbing';\n                    return;\n                }\n            }\n        }\n        // Start dragging images\n        this.isDragging = true;\n        this.dragStartX = e.clientX;\n        this.dragStartY = e.clientY;\n        // Determine which side was clicked for shift+drag\n        if (e.shiftKey && this.state.isWipeEnabled &&\n            this.state.imageALoaded && this.state.imageBLoaded) {\n            const wipePos = getWipePositionInCanvasCoords(this.state);\n            const angle = this.state.wipeAngle * (Math.PI / 180);\n            const mouseX = x - wipePos.x;\n            const mouseY = y - wipePos.y;\n            // Calculate which side of the wipe line we're on\n            const dotProduct = mouseX * Math.cos(angle) + mouseY * Math.sin(angle);\n            this.dragSide = dotProduct < 0 ? 'A' : 'B';\n            this.state.canvas.style.cursor = 'grabbing';\n        }\n        else {\n            this.state.canvas.style.cursor = 'move';\n        }\n    }\n    /**\n     * Handle mouse move events on the canvas.\n     * Updates mouse info, handles dragging, and manages cursor states.\n     */\n    handleMouseMove(e) {\n        const rect = this.state.canvas.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n        // Store current mouse position\n        this.lastMouseX = x;\n        this.lastMouseY = y;\n        // Update mouse position info and color values\n        this.updateMouseInfo(x, y);\n        // Handle wipe UI interaction\n        if (this.activeHandle) {\n            this.handleWipeUIInteraction(x, y);\n            return;\n        }\n        // Handle dragging images\n        if (this.isDragging) {\n            const dx = e.clientX - this.dragStartX;\n            const dy = e.clientY - this.dragStartY;\n            if (e.shiftKey && this.state.isWipeEnabled &&\n                this.state.imageALoaded && this.state.imageBLoaded && this.dragSide) {\n                // Move only one image - accumulate fractional movements\n                this.accumulatedDX += dx / this.state.scale;\n                this.accumulatedDY += dy / this.state.scale;\n                // Apply integer pixel movements\n                const intDX = Math.round(this.accumulatedDX);\n                const intDY = Math.round(this.accumulatedDY);\n                if (intDX !== 0 || intDY !== 0) {\n                    if (this.dragSide === 'A') {\n                        // Move only image A by integer pixels scaled appropriately\n                        this.state.offsetAX += intDX * this.state.scale;\n                        this.state.offsetAY += intDY * this.state.scale;\n                    }\n                    else {\n                        // Move only image B by integer pixels scaled appropriately\n                        this.state.offsetBX += intDX * this.state.scale;\n                        this.state.offsetBY += intDY * this.state.scale;\n                    }\n                    // Remove the applied movement from accumulated values\n                    this.accumulatedDX -= intDX;\n                    this.accumulatedDY -= intDY;\n                    this.draw();\n                    this.updatePSNR();\n                }\n            }\n            else {\n                // Move both images together\n                this.state.offsetX += dx;\n                this.state.offsetY += dy;\n                this.draw();\n            }\n            // Update drag start position for next movement\n            this.dragStartX = e.clientX;\n            this.dragStartY = e.clientY;\n        }\n        else {\n            // Update cursor based on what's under the mouse\n            this.updateCursor(x, y, e.shiftKey);\n        }\n        // Handle magnifier\n        if ((e.ctrlKey || e.metaKey) && this.state.magnifierZoomFactor && this.state.magnifierZoomFactor > 0) {\n            this.showMagnifier = true;\n            this.updateMagnifier(x, y);\n        }\n        else {\n            this.showMagnifier = false;\n            this.magnifierContainer.classList.add('hidden');\n        }\n    }\n    /**\n     * Handle mouse up events - stops dragging operations.\n     */\n    handleMouseUp(_e) {\n        this.isDragging = false;\n        this.activeHandle = null;\n        this.dragSide = null;\n        this.showMagnifier = false;\n        this.magnifierContainer.classList.add('hidden');\n        // Reset cursor\n        if (this.state.canvas) {\n            this.state.canvas.style.cursor = 'move';\n        }\n    }\n    /**\n     * Handle wheel events for zooming.\n     * Uses the original zoom calculation for smooth trackpad support.\n     */\n    handleWheel(e) {\n        e.preventDefault();\n        // Do nothing if no images are loaded\n        if (!this.state.imageALoaded && !this.state.imageBLoaded)\n            return;\n        const rect = this.state.canvas.getBoundingClientRect();\n        const mouseX = e.clientX - rect.left;\n        const mouseY = e.clientY - rect.top;\n        // Store old scale for ratio calculation\n        const oldScale = this.state.scale;\n        // Use the original zoom calculation for smooth trackpad support\n        // zoomPerWheelDelta = 1.00152 provides smooth zooming on trackpads\n        const zoomPerWheelDelta = 1.00152;\n        const zoomFactor = Math.pow(zoomPerWheelDelta, -e.deltaY);\n        // Apply the calculated zoom factor to the current scale\n        this.state.scale *= zoomFactor;\n        // Calculate the scale ratio between new and old scale\n        // This is used to adjust offsets proportionally\n        const scaleRatio = this.state.scale / oldScale;\n        // Update the global offset to keep the mouse point fixed during zoom\n        // This creates the effect of zooming centered on the mouse position\n        // The formula ensures that the point under the mouse remains stationary\n        this.state.offsetX = mouseX - scaleRatio * (mouseX - this.state.offsetX);\n        this.state.offsetY = mouseY - scaleRatio * (mouseY - this.state.offsetY);\n        // Scale the individual image offsets by the same ratio\n        // This maintains the relative positioning of images A and B\n        this.state.offsetAX *= scaleRatio;\n        this.state.offsetAY *= scaleRatio;\n        this.state.offsetBX *= scaleRatio;\n        this.state.offsetBY *= scaleRatio;\n        // Redraw the canvas with the new scale and offsets\n        this.draw();\n        // Update magnifier if it's currently active to reflect the new zoom level\n        // The magnifier content needs to be refreshed when the underlying scale changes\n        if (this.showMagnifier) {\n            this.updateMagnifier(mouseX, mouseY);\n        }\n    }\n    /**\n     * Handle wipe UI interactions (dragging handles).\n     * Matches the original handleWipeUIInteraction function exactly.\n     */\n    handleWipeUIInteraction(x, y) {\n        const wipePos = getWipePositionInCanvasCoords(this.state);\n        if (this.activeHandle === 'translation') {\n            // Update image coordinates directly - match original exactly\n            // Canvas coordinates will be computed on-demand from these\n            this.state.wipePositionInImageACoords = this.canvasToImageCoords(x, y, 'A');\n        }\n        else if (this.activeHandle === 'rotation') {\n            // Calculate angle from wipe position to mouse position\n            const dx = x - wipePos.x;\n            const dy = y - wipePos.y;\n            // Convert from radians to degrees (0° is right, 90° is down)\n            this.state.wipeAngle = Math.atan2(dy, dx) * (180 / Math.PI);\n        }\n        else if (this.activeHandle === 'alpha') {\n            // Calculate angle from wipe position to mouse position\n            const dx = x - wipePos.x;\n            const dy = y - wipePos.y;\n            // Calculate the absolute angle in degrees from the wipe center to the mouse position\n            // atan2 returns angle in radians (-π to π), convert to degrees (-180° to 180°)\n            const clickAngle = Math.atan2(dy, dx) * (180 / Math.PI);\n            // Calculate relative angle from the wipe angle\n            // This gives us the angle in the wipe's coordinate system where:\n            // - 0° is along the wipe line\n            // - 90° is perpendicular to the wipe line\n            // Add 360° and use modulo to ensure the result is in the range 0-360°\n            const relativeAngle = 360 - ((clickAngle - this.state.wipeAngle + 360) % 360);\n            // Map the angle to alpha value:\n            // - The alpha slider arc spans from 20° to 70° relative to the wipe line\n            // - 20° corresponds to alpha = 1.0 (fully opaque)\n            // - 70° corresponds to alpha = 0.0 (fully transparent)\n            if (relativeAngle >= UI_CONSTANTS.ALPHA_ARC_END_ANGLE && relativeAngle <= UI_CONSTANTS.ALPHA_ARC_START_ANGLE) {\n                // Linear mapping from angle to alpha within the valid range\n                // Formula: alpha = 1 - (angle - minAngle) / (maxAngle - minAngle)\n                this.state.wipeAlpha = 1 - ((relativeAngle - UI_CONSTANTS.ALPHA_ARC_END_ANGLE) / (UI_CONSTANTS.ALPHA_ARC_START_ANGLE - UI_CONSTANTS.ALPHA_ARC_END_ANGLE));\n            }\n            else if (relativeAngle < UI_CONSTANTS.ALPHA_ARC_START_ANGLE || relativeAngle > ((UI_CONSTANTS.ALPHA_ARC_START_ANGLE + UI_CONSTANTS.ALPHA_ARC_END_ANGLE) / 2 + 180) % 360) {\n                // If the angle is less than 20° or greater than 225°,\n                // set to maximum alpha (1.0)\n                // This creates a \"snap to max\" behavior when the mouse is in these regions\n                this.state.wipeAlpha = 1;\n            }\n            else if (relativeAngle > UI_CONSTANTS.ALPHA_ARC_END_ANGLE) {\n                // If the angle is greater than 70° but less than 225°,\n                // set to minimum alpha (0.0)\n                // This creates a \"snap to min\" behavior when the mouse is in this region\n                this.state.wipeAlpha = 0;\n            }\n        }\n        // Redraw the canvas with the updated wipe settings\n        this.draw();\n    }\n    /**\n     * Updates position and RGBA information for a specific image at the given canvas coordinates.\n     *\n     * This shared function handles the common logic for both image A and image B information display,\n     * eliminating code duplication while maintaining type safety and proper state management.\n     * The function calculates image coordinates, validates bounds, extracts pixel data, and updates\n     * the corresponding DOM elements with position and color information.\n     *\n     * @param x - Canvas X coordinate where the mouse is positioned\n     * @param y - Canvas Y coordinate where the mouse is positioned\n     * @param imageType - Which image to process ('A' or 'B')\n     *\n     * @remarks\n     * This method performs several operations:\n     * 1. Converts canvas coordinates to image coordinates\n     * 2. Validates that coordinates are within image bounds\n     * 3. Extracts RGBA pixel data at the specified location\n     * 4. Updates position and color display elements\n     * 5. Handles edge cases with appropriate fallback values\n     *\n     * The function uses conditional logic to access the correct state properties\n     * and DOM elements based on the imageType parameter, ensuring type safety\n     * while sharing the common coordinate and pixel extraction logic.\n     *\n     * @example\n     * ```typescript\n     * // Update info for image A\n     * this.updateImageInfo(mouseX, mouseY, 'A');\n     *\n     * // Update info for image B\n     * this.updateImageInfo(mouseX, mouseY, 'B');\n     * ```\n     */\n    updateImageInfo(x, y, imageType) {\n        // Get image-specific elements and state using factorized helper\n        const { isLoaded, image, imageData, coordsRgbaElement } = this.getImageElements(imageType);\n        // Process image information if the image is loaded and available\n        if (isLoaded && image) {\n            // Convert canvas coordinates to image coordinates for the specified image type\n            const imageCoords = this.canvasToImageCoords(x, y, imageType);\n            const imageX = Math.floor(imageCoords.x);\n            const imageY = Math.floor(imageCoords.y);\n            // Extract and display RGBA values if image data is available and coordinates are valid\n            if (imageData &&\n                imageCoords.x >= 0 && imageCoords.x < image.width &&\n                imageCoords.y >= 0 && imageCoords.y < image.height) {\n                // Calculate pixel index in the ImageData array (4 bytes per pixel: RGBA)\n                const pixelIndex = (imageY * image.width + imageX) * 4;\n                // Extract individual color channel values from the ImageData\n                const r = String(imageData.data[pixelIndex]).padStart(3, '0');\n                const g = String(imageData.data[pixelIndex + 1]).padStart(3, '0');\n                const b = String(imageData.data[pixelIndex + 2]).padStart(3, '0');\n                const a = String(imageData.data[pixelIndex + 3]).padStart(3, '0');\n                // Display the combined coordinates and RGBA values in the requested format\n                coordsRgbaElement.textContent = ` [${imageX},${imageY}]=(${r},${g},${b},${a})`;\n            }\n            else {\n                // Display placeholder when coordinates are outside image bounds\n                coordsRgbaElement.textContent = ` [${imageX},${imageY}]=(-,-,-,-)`;\n            }\n        }\n        else {\n            // Clear display when image is not loaded\n            coordsRgbaElement.textContent = '';\n        }\n    }\n    /**\n     * Update mouse information display and cursor.\n     */\n    updateMouseInfo(x, y) {\n        // Update position and color information for both images using the shared function\n        // This eliminates code duplication while maintaining identical functionality\n        this.updateImageInfo(x, y, 'A');\n        this.updateImageInfo(x, y, 'B');\n    }\n    /**\n     * Updates the mouse cursor appearance based on the current mouse position and interaction context.\n     *\n     * This method determines the appropriate cursor style by analyzing what UI elements or interactive\n     * areas are under the mouse pointer. It handles various cursor states including:\n     * - Move cursor for general canvas interaction\n     * - Grab cursor for interactive handles (wipe controls)\n     * - Grabbing cursor during active drag operations\n     * - Hidden cursor when magnifier is active\n     *\n     * The cursor update is skipped entirely when the magnifier is active to maintain the hidden\n     * cursor state that provides a clean magnification experience without visual distractions.\n     *\n     * @param x - Mouse X coordinate in canvas coordinate system\n     * @param y - Mouse Y coordinate in canvas coordinate system\n     * @param shiftKey - Whether the Shift key is currently pressed (affects cursor for image-specific dragging)\n     *\n     * @remarks\n     * This method is called frequently during mouse movement and must be performant. It uses\n     * early returns to avoid unnecessary calculations when the magnifier is active or when\n     * the canvas is not available.\n     *\n     * @example\n     * ```typescript\n     * // Called from mouse move handler\n     * this.updateCursor(mouseX, mouseY, event.shiftKey);\n     * ```\n     */\n    updateCursor(x, y, shiftKey) {\n        // Early exit if canvas is not available - prevents null reference errors\n        if (!this.state.canvas)\n            return;\n        // Critical: Don't update cursor when magnifier is active - it should stay hidden\n        // The magnifier provides a clean viewing experience without cursor distractions\n        // This prevents the updateCursor method from overriding the 'none' cursor style\n        // that was set when the magnifier was activated via Control key press\n        if (this.showMagnifier) {\n            return;\n        }\n        // Default cursor for general canvas interaction - indicates draggable content\n        let cursor = 'move';\n        // Check if over a wipe handle\n        if (this.state.isWipeEnabled && this.state.imageALoaded && this.state.imageBLoaded) {\n            const wipePos = getWipePositionInCanvasCoords(this.state);\n            // Check translation handle (center dot) - available in both simple and full wipe modes\n            const distToCenter = Math.sqrt(Math.pow(x - wipePos.x, 2) +\n                Math.pow(y - wipePos.y, 2));\n            if (distToCenter <= UI_CONSTANTS.TRANSLATION_HANDLE_RADIUS) {\n                cursor = 'grab';\n            }\n            else if (!this.state.isSimpleWipe) {\n                // For full wipe interface, check additional handles\n                // Check rotation handle\n                const { x: rotX, y: rotY } = calculateRotationHandlePosition(wipePos, this.state.wipeAngle);\n                const distToRotHandle = Math.sqrt(Math.pow(x - rotX, 2) +\n                    Math.pow(y - rotY, 2));\n                if (distToRotHandle <= UI_CONSTANTS.ROTATION_HANDLE_RADIUS) {\n                    cursor = 'grab';\n                }\n                else {\n                    // Check alpha handle\n                    const alphaSliderPos = calculateAlphaSliderPosition(wipePos, this.state.wipeAngle, this.state.wipeAlpha);\n                    const alphaX = alphaSliderPos.x;\n                    const alphaY = alphaSliderPos.y;\n                    const distToAlphaHandle = Math.sqrt(Math.pow(x - alphaX, 2) +\n                        Math.pow(y - alphaY, 2));\n                    if (distToAlphaHandle <= UI_CONSTANTS.ALPHA_HANDLE_RADIUS) {\n                        cursor = 'grab';\n                    }\n                }\n            }\n        }\n        // Modify cursor for shift key\n        if (shiftKey && this.state.isWipeEnabled &&\n            this.state.imageALoaded && this.state.imageBLoaded) {\n            cursor = 'grab';\n        }\n        this.state.canvas.style.cursor = cursor;\n    }\n    /**\n     * Update magnifier position and content.\n     */\n    updateMagnifier(x, y) {\n        if (!this.showMagnifier)\n            return;\n        // Position and render the magnifier using the dedicated module\n        updateMagnifier(this.magnifierContainer, this.magnifierCanvas, x, y, this.state);\n        this.magnifierContainer.classList.remove('hidden');\n    }\n    /**\n     * Handle drag over events for file dropping.\n     */\n    handleDragOver(e) {\n        e.preventDefault();\n        if (e.dataTransfer?.types.includes('Files')) {\n            this.dragMessage.textContent = 'Drop images to load';\n            this.dragMessage.style.opacity = '1';\n        }\n    }\n    /**\n     * Handle drop events for file dropping.\n     */\n    handleDrop(e) {\n        e.preventDefault();\n        this.dragMessage.style.opacity = '0';\n        if (e.dataTransfer?.files && e.dataTransfer.files.length > 0) {\n            const target = e.target;\n            if (target === this.uploadA || this.uploadA.contains(target)) {\n                const file = e.dataTransfer.files[0];\n                const url = URL.createObjectURL(file);\n                this.loadImage(url, 'A', file.name);\n            }\n            else if (target === this.uploadB || this.uploadB.contains(target)) {\n                const file = e.dataTransfer.files[0];\n                const url = URL.createObjectURL(file);\n                this.loadImage(url, 'B', file.name);\n            }\n            else {\n                // Drop anywhere else - load first as A, second as B\n                if (e.dataTransfer.files.length >= 1) {\n                    const fileA = e.dataTransfer.files[0];\n                    const urlA = URL.createObjectURL(fileA);\n                    this.loadImage(urlA, 'A', fileA.name);\n                }\n                if (e.dataTransfer.files.length >= 2) {\n                    const fileB = e.dataTransfer.files[1];\n                    const urlB = URL.createObjectURL(fileB);\n                    this.loadImage(urlB, 'B', fileB.name);\n                }\n            }\n        }\n    }\n    /**\n     * Handle keyboard events - only when component has focus.\n     */\n    handleKeyDown(e) {\n        // Prevent default to avoid browser shortcuts\n        e.preventDefault();\n        switch (e.key.toLowerCase()) {\n            case 'v':\n                // Simple wipe mode\n                if (this.state.isSimpleWipe) {\n                    // Already in simple wipe, center the wipe\n                    this.centerWipePosition();\n                }\n                else {\n                    this.setWipeMode(true);\n                }\n                break;\n            case 'w':\n                // Full wipe mode\n                if (!this.state.isSimpleWipe && this.state.isWipeEnabled) {\n                    // Already in full wipe, center the wipe\n                    this.centerWipePosition();\n                }\n                else {\n                    this.setWipeMode(false);\n                }\n                break;\n            case 'a':\n                this.setDisplayMode('A');\n                break;\n            case 'b':\n                this.setDisplayMode('B');\n                break;\n            case 'u':\n                this.setDisplayMode('Under');\n                break;\n            case 'o':\n                this.setDisplayMode('OnionSkin');\n                break;\n            case 'd':\n                this.setDisplayMode('Diff');\n                break;\n            case 'i':\n                this.setDisplayMode('InvDiff');\n                break;\n            case 'c':\n                this.state.isCheckerboard = !this.state.isCheckerboard;\n                this.draw();\n                break;\n            case 'r':\n                // Reset view\n                this.resetView();\n                break;\n            case 'h':\n            case '?':\n                // Toggle help screen\n                this.state.showHelp = !this.state.showHelp;\n                this.manuallyToggledHelp = true;\n                this.updateHelpScreenVisibility();\n                break;\n            case 'control':\n                // Show magnifier only if zoom factor is greater than 0\n                if (this.state.magnifierZoomFactor && this.state.magnifierZoomFactor > 0) {\n                    this.showMagnifier = true;\n                    this.magnifierContainer.classList.remove('hidden');\n                    // Hide cursor when magnifier is active\n                    this.state.canvas.style.cursor = 'none';\n                    // Use the last known mouse position\n                    if (this.lastMouseX !== 0 && this.lastMouseY !== 0) {\n                        this.updateMagnifier(this.lastMouseX, this.lastMouseY);\n                    }\n                    else if (this.state.canvas) {\n                        // If no mouse position is known, use the center of the canvas\n                        const x = this.state.canvas.width / 2;\n                        const y = this.state.canvas.height / 2;\n                        this.updateMagnifier(x, y);\n                    }\n                }\n                break;\n        }\n    }\n    /**\n     * Handle key up events.\n     */\n    handleKeyUp(e) {\n        // Update cursor when shift key is released\n        if (e.key === 'Shift') {\n            this.updateCursor(this.lastMouseX, this.lastMouseY, false);\n        }\n        else if (e.key.toLowerCase() === 'control') {\n            // Hide magnifier when Control key is released\n            this.showMagnifier = false;\n            this.magnifierContainer.classList.add('hidden');\n            // Restore appropriate cursor\n            this.updateCursor(this.lastMouseX, this.lastMouseY, false);\n        }\n    }\n    /**\n     * Extract filename from URL, handling blob URLs properly.\n     */\n    extractFilename(url) {\n        // If it's a blob URL, we can't extract the original filename\n        if (url.startsWith('blob:')) {\n            return 'Uploaded file';\n        }\n        // For regular URLs, extract the filename\n        const parts = url.split('/');\n        const filename = parts[parts.length - 1];\n        // Remove query parameters if present\n        const cleanFilename = filename.split('?')[0];\n        return cleanFilename || 'Unknown file';\n    }\n    /**\n     * Reset view to fit images and center wipe.\n     * Matches the original resetView function exactly.\n     */\n    resetView() {\n        // Do nothing if no images are loaded\n        if (!this.state.imageALoaded && !this.state.imageBLoaded)\n            return;\n        // Reset zoom and position\n        this.state.scale = 1;\n        this.state.offsetX = 0;\n        this.state.offsetY = 0;\n        this.state.offsetAX = 0;\n        this.state.offsetAY = 0;\n        this.state.offsetBX = 0;\n        this.state.offsetBY = 0;\n        // Reset wipe settings\n        this.state.wipeAngle = 0;\n        this.state.wipeAlpha = 1;\n        this.state.isSimpleWipe = false;\n        // Update attributes to reflect reset state\n        this.setAttribute('wipe-angle', '0');\n        this.setAttribute('wipe-alpha', '1');\n        this.setAttribute('wipe-mode', 'full');\n        // Center the image(s) - match original logic exactly\n        if (this.state.imageALoaded && this.state.imageA && this.state.canvas) {\n            // Center image A\n            const targetWidth = this.state.imageA.width;\n            const targetHeight = this.state.imageA.height;\n            // Calculate scale to fit 90% of the canvas\n            this.state.scale = Math.min(this.state.canvas.width / targetWidth, this.state.canvas.height / targetHeight) * 0.9;\n            // Center the image\n            this.state.offsetX = (this.state.canvas.width - targetWidth * this.state.scale) / 2;\n            this.state.offsetY = (this.state.canvas.height - targetHeight * this.state.scale) / 2;\n        }\n        else if (this.state.imageBLoaded && this.state.imageB && this.state.canvas) {\n            // Center image B\n            const targetWidth = this.state.imageB.width;\n            const targetHeight = this.state.imageB.height;\n            // Calculate scale to fit 90% of the canvas\n            this.state.scale = Math.min(this.state.canvas.width / targetWidth, this.state.canvas.height / targetHeight) * 0.9;\n            // Center the image\n            this.state.offsetX = (this.state.canvas.width - targetWidth * this.state.scale) / 2;\n            this.state.offsetY = (this.state.canvas.height - targetHeight * this.state.scale) / 2;\n        }\n        // Set wipe position to center of image A\n        if (this.state.imageALoaded && this.state.canvas) {\n            this.centerWipePosition();\n        }\n        // Redraw the canvas and update PSNR\n        this.draw();\n        this.updatePSNR();\n    }\n    // Placeholder methods for file input handling and coordinate conversion\n    /**\n     * Generic file input handler that processes file selection for both image A and B.\n     *\n     * This method provides a unified approach to handling file input events from\n     * both upload boxes within the web component, eliminating code duplication and\n     * ensuring consistent file processing behavior. It performs comprehensive\n     * file handling operations:\n     *\n     * **Input Validation and Safety:**\n     * - Safely casts the event target to HTMLInputElement for type safety\n     * - Verifies that files exist and at least one file was selected\n     * - Provides robust error handling for invalid or missing file inputs\n     *\n     * **File Processing Workflow:**\n     * 1. **File Extraction**: Safely extracts the first selected file from the input\n     * 2. **URL Generation**: Creates an object URL for the file to enable loading\n     * 3. **Image Loading**: Delegates to the loadImage method with proper parameters\n     * 4. **Filename Preservation**: Passes the original filename for display purposes\n     *\n     * **Component Integration:**\n     * - Integrates seamlessly with the component's image loading system\n     * - Maintains proper context and state management within the component\n     * - Supports both A and B image slots through the imageType parameter\n     *\n     * **Memory Management:**\n     * The method creates object URLs that should be properly cleaned up by the\n     * loadImage method to prevent memory leaks from accumulated blob URLs.\n     *\n     * Factorized from separate handleFileInputA and handleFileInputB methods\n     * to reduce code duplication and provide a single point of maintenance\n     * for file input processing logic within the component.\n     *\n     * @param e - The file input change event containing the selected file(s)\n     * @param imageType - The target image slot ('A' or 'B') for the loaded image\n     *\n     * @example\n     * ```typescript\n     * // Used internally by the component for both A and B file inputs\n     * this.handleFileInput(event, 'A'); // Load into image A slot\n     * this.handleFileInput(event, 'B'); // Load into image B slot\n     * ```\n     *\n     * @see {@link loadImage} - The method that actually loads and processes the image file\n     * @see {@link handleFileInputA} - Wrapper method for image A file input\n     * @see {@link handleFileInputB} - Wrapper method for image B file input\n     */\n    handleFileInput(e, imageType) {\n        // Cast the event target to HTMLInputElement for type safety and access to files\n        const input = e.target;\n        // Verify that files exist and at least one file was selected\n        if (input.files && input.files[0]) {\n            const file = input.files[0]; // Extract the first selected file\n            const url = URL.createObjectURL(file); // Create object URL for loading\n            // Load the image with the generated URL, target slot, and original filename\n            this.loadImage(url, imageType, file.name);\n        }\n    }\n    /**\n     * Handles file input events specifically for image A upload box.\n     *\n     * This method serves as a specialized wrapper around the generic handleFileInput\n     * method, providing a dedicated entry point for image A file selection events.\n     * It maintains the existing method signature for backward compatibility while\n     * leveraging the factorized file handling logic.\n     *\n     * @param e - The file input change event from the image A file input element\n     *\n     * @see {@link handleFileInput} - The generic file handler this method delegates to\n     */\n    handleFileInputA(e) {\n        this.handleFileInput(e, 'A');\n    }\n    /**\n     * Handles file input events specifically for image B upload box.\n     *\n     * This method serves as a specialized wrapper around the generic handleFileInput\n     * method, providing a dedicated entry point for image B file selection events.\n     * It maintains the existing method signature for backward compatibility while\n     * leveraging the factorized file handling logic.\n     *\n     * @param e - The file input change event from the image B file input element\n     *\n     * @see {@link handleFileInput} - The generic file handler this method delegates to\n     */\n    handleFileInputB(e) {\n        this.handleFileInput(e, 'B');\n    }\n    /**\n     * Convert canvas coordinates to image coordinates.\n     * @param canvasX - X coordinate in canvas space\n     * @param canvasY - Y coordinate in canvas space\n     * @param imageType - Which image coordinate system to use\n     * @returns Image coordinates\n     */\n    canvasToImageCoords(canvasX, canvasY, imageType) {\n        return canvasToImageCoords(canvasX, canvasY, imageType, this.state);\n    }\n    /**\n     * Draw the canvas using the comprehensive drawing module.\n     */\n    draw() {\n        if (!this.state.ctx || !this.state.canvas)\n            return;\n        // Use the comprehensive drawing module\n        drawCanvas(this.state);\n    }\n}\n// Register the custom element\ncustomElements.define('image-comparison', ImageComparisonElement);\n//# sourceMappingURL=image-comparison-element.js.map"],"names":[],"sourceRoot":""}